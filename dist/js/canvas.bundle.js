/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/js/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./boxes.json":
/*!********************!*\
  !*** ./boxes.json ***!
  \********************/
/*! exports provided: boxes, default */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"{\\\"boxes\\\":[{\\\"LI\\\":55,\\\"message\\\":\\\"This is a sample box\\\"},{\\\"LI\\\":16,\\\"message\\\":\\\"This is a sample box\\\"},{\\\"LI\\\":450,\\\"message\\\":\\\"This is a sample box\\\"},{\\\"LI\\\":33,\\\"message\\\":\\\"This is a sample box\\\"},{\\\"LI\\\":100,\\\"message\\\":\\\"This is a sample box\\\"}]}\");\n\n//# sourceURL=webpack:///./boxes.json?");

/***/ }),

/***/ "./src/js/GenerateBox.js":
/*!*******************************!*\
  !*** ./src/js/GenerateBox.js ***!
  \*******************************/
/*! exports provided: generateBox */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"generateBox\", function() { return generateBox; });\nfunction generateBox(indLoc, message) {\n  var boxObject = {\n    location: indLoc,\n    messge: message\n  };\n  return boxObject;\n}\n\n//# sourceURL=webpack:///./src/js/GenerateBox.js?");

/***/ }),

/***/ "./src/js/box.js":
/*!***********************!*\
  !*** ./src/js/box.js ***!
  \***********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return box; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar box = function box(sprite, message, name, locationIndex) {\n  _classCallCheck(this, box);\n\n  this.sprite = sprite;\n  this.message = message;\n  this.name = name;\n  this.locationIndex = locationIndex;\n};\n\n\n\n//# sourceURL=webpack:///./src/js/box.js?");

/***/ }),

/***/ "./src/js/library/collision.js":
/*!*************************************!*\
  !*** ./src/js/library/collision.js ***!
  \*************************************/
/*! exports provided: hitTestPoint, hitTestCircle, circleCollision, movingCircleCollision, multipleCircleCollision, hitTestRectangle, rectangleCollision, hitTestCircleRectangle, hitTestCirclePoint, circleRectangleCollision, circlePointCollision, hit */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hitTestPoint\", function() { return hitTestPoint; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hitTestCircle\", function() { return hitTestCircle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"circleCollision\", function() { return circleCollision; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"movingCircleCollision\", function() { return movingCircleCollision; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multipleCircleCollision\", function() { return multipleCircleCollision; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hitTestRectangle\", function() { return hitTestRectangle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rectangleCollision\", function() { return rectangleCollision; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hitTestCircleRectangle\", function() { return hitTestCircleRectangle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hitTestCirclePoint\", function() { return hitTestCirclePoint; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"circleRectangleCollision\", function() { return circleRectangleCollision; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"circlePointCollision\", function() { return circlePointCollision; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hit\", function() { return hit; });\n/* \r\ncollision.js\r\n============\r\n\r\nThis JavaScript file contains 6 collision functions:\r\n\r\n- hitTestPoint\r\n- hitTestCircle\r\n- rectangleCollision\r\n- circleCollision\r\n- movingCircleCollision\r\n- bounceOffSurface\r\n\r\nTo use them you'll need sprite objects with these minimum properties:\r\n\r\n    x, y, center.x, center.y, width, height\r\n\r\nFor rectangular sprites, you need these additional properties:\r\n\r\n    halfWidth, halfHeight\r\n\r\nFor circular sprites, you need these additional properties:\r\n\r\n    diameter, radius\r\n\r\nOptionally the sprites can include a mass property:\r\n\r\n    mass\r\n\r\nMass should have a value greater than 1.\r\n\r\nSee the `sprite.js` file for an example of sprite prototype objects\r\nthat use these properties.\r\n\r\n*/\n\n/*\r\nhitTestPoint\r\n------------\r\n\r\nUse it to find out if a point is touching a circlular or rectangular sprite.\r\nParameters: \r\na. An object with `x` and `y` properties.\r\nb. A sprite object with `x`, `y`, `centerX` and `centerY` properties.\r\nIf the sprite has a `radius` property, the function will interpret\r\nthe shape as a circle.\r\n*/\nfunction hitTestPoint(point, sprite) {\n  var shape, left, right, top, bottom, vx, vy, magnitude, hit; //Find out if the sprite is rectangular or circular depending\n  //on whether it has a `radius` property\n\n  if (sprite.radius) {\n    shape = \"circle\";\n  } else {\n    shape = \"rectangle\";\n  } //Rectangle\n\n\n  if (shape === \"rectangle\") {\n    //Get the position of the sprite's edges\n    left = sprite.x;\n    right = sprite.x + sprite.width;\n    top = sprite.y;\n    bottom = sprite.y + sprite.height; //Find out if the point is intersecting the rectangle\n\n    hit = point.x > left && point.x < right && point.y > top && point.y < bottom;\n  } //Circle\n\n\n  if (shape === \"circle\") {\n    //Find the distance between the point and the\n    //center of the circle\n    vx = point.x - sprite.centerX, vy = point.y - sprite.centerY, magnitude = Math.sqrt(vx * vx + vy * vy); //The point is intersecting the circle if the magnitude\n    //(distance) is less than the circle's radius\n\n    hit = magnitude < sprite.radius;\n  } //`hit` will be either `true` or `false`\n\n\n  return hit;\n}\n/*\r\nhitTestCircle\r\n-------------\r\n\r\nUse it to find out if two circular sprites are touching.\r\nParameters: \r\na. A sprite object with `centerX`, `centerY` and `radius` properties.\r\nb. A sprite object with `centerX`, `centerY` and `radius`.\r\n*/\n\nfunction hitTestCircle(c1, c2) {\n  var global = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var vx, vy, magnitude, combinedRadii, hit; //Calculate the vector between the circles’ center points\n\n  if (global) {\n    //Use global coordinates\n    vx = c2.gx + c2.radius - (c1.gx + c1.radius);\n    vy = c2.gy + c2.radius - (c1.gy + c1.radius);\n  } else {\n    //Use local coordinates\n    vx = c2.centerX - c1.centerX;\n    vy = c2.centerY - c1.centerY;\n  } //Find the distance between the circles by calculating\n  //the vector's magnitude (how long the vector is)\n\n\n  magnitude = Math.sqrt(vx * vx + vy * vy); //Add together the circles' total radii\n\n  combinedRadii = c1.radius + c2.radius; //Set `hit` to `true` if the distance between the circles is\n  //less than their `combinedRadii`\n\n  hit = magnitude < combinedRadii; //`hit` will be either `true` or `false`\n\n  return hit;\n}\n;\n/*\r\ncircleCollision\r\n---------------\r\n\r\nUse it to prevent a moving circular sprite from overlapping and optionally\r\nbouncing off a non-moving circular sprite.\r\nParameters: \r\na. A sprite object with `x`, `y` `centerX`, `centerY` and `radius` properties.\r\nb. A sprite object with `x`, `y` `centerX`, `centerY` and `radius` properties.\r\nc. Optional: true or false to indicate whether or not the first sprite\r\nshould bounce off the second sprite.\r\nThe sprites can contain an optional mass property that should be greater than 1.\r\n\r\n*/\n\nfunction circleCollision(c1, c2) {\n  var bounce = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var global = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var magnitude,\n      combinedRadii,\n      overlap,\n      vx,\n      vy,\n      dx,\n      dy,\n      s = {},\n      hit = false; //Calculate the vector between the circles’ center points\n\n  if (global) {\n    //Use global coordinates\n    vx = c2.gx + c2.radius - (c1.gx + c1.radius);\n    vy = c2.gy + c2.radius - (c1.gy + c1.radius);\n  } else {\n    //Use local coordinates\n    vx = c2.centerX - c1.centerX;\n    vy = c2.centerY - c1.centerY;\n  } //Find the distance between the circles by calculating\n  //the vector's magnitude (how long the vector is)\n\n\n  magnitude = Math.sqrt(vx * vx + vy * vy); //Add together the circles' combined half-widths\n\n  combinedRadii = c1.radius + c2.radius; //Figure out if there's a collision\n\n  if (magnitude < combinedRadii) {\n    //Yes, a collision is happening\n    hit = true; //Find the amount of overlap between the circles\n\n    overlap = combinedRadii - magnitude; //Add some \"quantum padding\". This adds a tiny amount of space\n    //between the circles to reduce their surface tension and make\n    //them more slippery. \"0.3\" is a good place to start but you might\n    //need to modify this slightly depending on the exact behaviour\n    //you want. Too little and the balls will feel sticky, too much\n    //and they could start to jitter if they're jammed together\n\n    var quantumPadding = 0.3;\n    overlap += quantumPadding; //Normalize the vector\n    //These numbers tell us the direction of the collision\n\n    dx = vx / magnitude;\n    dy = vy / magnitude; //Move circle 1 out of the collision by multiplying\n    //the overlap with the normalized vector and subtract it from\n    //circle 1's position\n\n    c1.x -= overlap * dx;\n    c1.y -= overlap * dy; //Bounce\n\n    if (bounce) {\n      //Create a collision vector object, `s` to represent the bounce \"surface\".\n      //Find the bounce surface's x and y properties\n      //(This represents the normal of the distance vector between the circles)\n      s.x = vy;\n      s.y = -vx; //Bounce c1 off the surface\n\n      bounceOffSurface(c1, s);\n    }\n  }\n\n  return hit;\n}\n/*\r\nmovingCircleCollision\r\n---------------------\r\n\r\nUse it to make two moving circles bounce off each other.\r\nParameters: \r\na. A sprite object with `x`, `y` `centerX`, `centerY` and `radius` properties.\r\nb. A sprite object with `x`, `y` `centerX`, `centerY` and `radius` properties.\r\nThe sprites can contain an optional mass property that should be greater than 1.\r\n\r\n*/\n\nfunction movingCircleCollision(c1, c2) {\n  var global = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var combinedRadii,\n      overlap,\n      xSide,\n      ySide,\n      //`s` refers to the distance vector between the circles\n  s = {},\n      p1A = {},\n      p1B = {},\n      p2A = {},\n      p2B = {},\n      hit = false; //Apply mass, if the circles have mass properties\n\n  c1.mass = c1.mass || 1;\n  c2.mass = c2.mass || 1; //Calculate the vector between the circles’ center points\n\n  if (global) {\n    //Use global coordinates\n    s.vx = c2.gx + c2.radius - (c1.gx + c1.radius);\n    s.vy = c2.gy + c2.radius - (c1.gy + c1.radius);\n  } else {\n    //Use local coordinates\n    s.vx = c2.centerX - c1.centerX;\n    s.vy = c2.centerY - c1.centerY;\n  } //Find the distance between the circles by calculating\n  //the vector's magnitude (how long the vector is)\n\n\n  s.magnitude = Math.sqrt(s.vx * s.vx + s.vy * s.vy); //Add together the circles' combined half-widths\n\n  combinedRadii = c1.radius + c2.radius; //Figure out if there's a collision\n\n  if (s.magnitude < combinedRadii) {\n    //Yes, a collision is happening\n    hit = true; //Find the amount of overlap between the circles\n\n    overlap = combinedRadii - s.magnitude; //Add some \"quantum padding\" to the overlap\n\n    overlap += 0.3; //Normalize the vector.\n    //These numbers tell us the direction of the collision\n\n    s.dx = s.vx / s.magnitude;\n    s.dy = s.vy / s.magnitude; //Find the collision vector.\n    //Divide it in half to share between the circles, and make it absolute\n\n    s.vxHalf = Math.abs(s.dx * overlap / 2);\n    s.vyHalf = Math.abs(s.dy * overlap / 2); //Find the side that the collision is occurring on\n\n    c1.x > c2.x ? xSide = 1 : xSide = -1;\n    c1.y > c2.y ? ySide = 1 : ySide = -1; //Move c1 out of the collision by multiplying\n    //the overlap with the normalized vector and adding it to\n    //the circles' positions\n\n    c1.x = c1.x + s.vxHalf * xSide;\n    c1.y = c1.y + s.vyHalf * ySide; //Move c2 out of the collision\n\n    c2.x = c2.x + s.vxHalf * -xSide;\n    c2.y = c2.y + s.vyHalf * -ySide; //1. Calculate the collision surface's properties\n    //Find the surface vector's left normal\n\n    s.lx = s.vy;\n    s.ly = -s.vx; //2. Bounce c1 off the surface (s)\n    //Find the dot product between c1 and the surface\n\n    var dp1 = c1.vx * s.dx + c1.vy * s.dy; //Project c1's velocity onto the collision surface\n\n    p1A.x = dp1 * s.dx;\n    p1A.y = dp1 * s.dy; //Find the dot product of c1 and the surface's left normal (s.lx and s.ly)\n\n    var dp2 = c1.vx * (s.lx / s.magnitude) + c1.vy * (s.ly / s.magnitude); //Project the c1's velocity onto the surface's left normal\n\n    p1B.x = dp2 * (s.lx / s.magnitude);\n    p1B.y = dp2 * (s.ly / s.magnitude); //3. Bounce c2 off the surface (s)\n    //Find the dot product between c2 and the surface\n\n    var dp3 = c2.vx * s.dx + c2.vy * s.dy; //Project c2's velocity onto the collision surface\n\n    p2A.x = dp3 * s.dx;\n    p2A.y = dp3 * s.dy; //Find the dot product of c2 and the surface's left normal (s.lx and s.ly)\n\n    var dp4 = c2.vx * (s.lx / s.magnitude) + c2.vy * (s.ly / s.magnitude); //Project c2's velocity onto the surface's left normal\n\n    p2B.x = dp4 * (s.lx / s.magnitude);\n    p2B.y = dp4 * (s.ly / s.magnitude); //4. Calculate the bounce vectors\n    //Bounce c1\n    //using p1B and p2A\n\n    c1.bounce = {};\n    c1.bounce.x = p1B.x + p2A.x;\n    c1.bounce.y = p1B.y + p2A.y; //Bounce c2\n    //using p1A and p2B\n\n    c2.bounce = {};\n    c2.bounce.x = p1A.x + p2B.x;\n    c2.bounce.y = p1A.y + p2B.y; //Add the bounce vector to the circles' velocity\n    //and add mass if the circle has a mass property\n\n    c1.vx = c1.bounce.x / c1.mass;\n    c1.vy = c1.bounce.y / c1.mass;\n    c2.vx = c2.bounce.x / c2.mass;\n    c2.vy = c2.bounce.y / c2.mass;\n  }\n\n  return hit;\n}\n/*\r\nmultipleCircleCollision\r\n-----------------------\r\n\r\nChecks all the circles in an array for a collision against\r\nall the other circles in an array, using `movingCircleCollision` (above)\r\n*/\n\nfunction multipleCircleCollision(arrayOfCircles) {\n  var global = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  //marble collisions\n  for (var i = 0; i < arrayOfCircles.length; i++) {\n    //The first marble to use in the collision check\n    var c1 = arrayOfCircles[i];\n\n    for (var j = i + 1; j < arrayOfCircles.length; j++) {\n      //The second marble to use in the collision check\n      var c2 = arrayOfCircles[j]; //Check for a collision and bounce the marbles apart if\n      //they collide. Use an optional mass property on the sprite\n      //to affect the bounciness of each marble\n\n      movingCircleCollision(c1, c2, global);\n    }\n  }\n}\n/*\r\nhitTestRectangle\r\n----------------\r\n\r\nUse it to find out if two rectangular sprites are touching.\r\nParameters: \r\na. A sprite object with `centerX`, `centerY`, `halfWidth` and `halfHeight` properties.\r\nb. A sprite object with `centerX`, `centerY`, `halfWidth` and `halfHeight` properties.\r\n\r\n*/\n\nfunction hitTestRectangle(r1, r2) {\n  var global = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var hit, combinedHalfWidths, combinedHalfHeights, vx, vy; //A variable to determine whether there's a collision\n\n  hit = false; //Calculate the distance vector\n\n  if (global) {\n    vx = r1.gx + r1.halfWidth - (r2.gx + r2.halfWidth);\n    vy = r1.gy + r1.halfHeight - (r2.gy + r2.halfHeight);\n  } else {\n    vx = r1.centerX - r2.centerX;\n    vy = r1.centerY - r2.centerY;\n  } //Figure out the combined half-widths and half-heights\n\n\n  combinedHalfWidths = r1.halfWidth + r2.halfWidth;\n  combinedHalfHeights = r1.halfHeight + r2.halfHeight; //Check for a collision on the x axis\n\n  if (Math.abs(vx) < combinedHalfWidths) {\n    //A collision might be occuring. Check for a collision on the y axis\n    if (Math.abs(vy) < combinedHalfHeights) {\n      //There's definitely a collision happening\n      hit = true;\n    } else {\n      //There's no collision on the y axis\n      hit = false;\n    }\n  } else {\n    //There's no collision on the x axis\n    hit = false;\n  } //`hit` will be either `true` or `false`\n\n\n  return hit;\n}\n/*\r\nrectangleCollision\r\n------------------\r\n\r\nUse it to prevent two rectangular sprites from overlapping. \r\nOptionally, make the first rectangle bounce off the second rectangle.\r\nParameters: \r\na. A sprite object with `x`, `y` `centerX`, `centerY`, `halfWidth` and `halfHeight` properties.\r\nb. A sprite object with `x`, `y` `centerX`, `centerY`, `halfWidth` and `halfHeight` properties.\r\nc. Optional: true or false to indicate whether or not the first sprite\r\nshould bounce off the second sprite.\r\n*/\n\nfunction rectangleCollision(r1, r2) {\n  var bounce = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var global = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  var collision, combinedHalfWidths, combinedHalfHeights, overlapX, overlapY, vx, vy; //Calculate the distance vector\n\n  if (global) {\n    vx = r1.gx + r1.halfWidth - (r2.gx + r2.halfWidth);\n    vy = r1.gy + r1.halfHeight - (r2.gy + r2.halfHeight);\n  } else {\n    vx = r1.centerX - r2.centerX;\n    vy = r1.centerY - r2.centerY;\n  } //Figure out the combined half-widths and half-heights\n\n\n  combinedHalfWidths = r1.halfWidth + r2.halfWidth;\n  combinedHalfHeights = r1.halfHeight + r2.halfHeight; //Check whether vx is less than the combined half widths\n\n  if (Math.abs(vx) < combinedHalfWidths) {\n    //A collision might be occurring!\n    //Check whether vy is less than the combined half heights\n    if (Math.abs(vy) < combinedHalfHeights) {\n      //A collision has occurred! This is good!\n      //Find out the size of the overlap on both the X and Y axes\n      overlapX = combinedHalfWidths - Math.abs(vx);\n      overlapY = combinedHalfHeights - Math.abs(vy); //The collision has occurred on the axis with the\n      //*smallest* amount of overlap. Let's figure out which\n      //axis that is\n\n      if (overlapX >= overlapY) {\n        //The collision is happening on the X axis\n        //But on which side? vy can tell us\n        if (vy > 0) {\n          collision = \"top\"; //Move the rectangle out of the collision\n\n          r1.y = r1.y + overlapY;\n        } else {\n          collision = \"bottom\"; //Move the rectangle out of the collision\n\n          r1.y = r1.y - overlapY;\n        } //Bounce\n\n\n        if (bounce) {\n          r1.vy *= -1;\n          /*Alternative\r\n          //Find the bounce surface's vx and vy properties\r\n          var s = {};\r\n          s.vx = r2.x - r2.x + r2.width;\r\n          s.vy = 0;\r\n            //Bounce r1 off the surface\r\n          //bounceOffSurface(r1, s);\r\n          */\n        }\n      } else {\n        //The collision is happening on the Y axis\n        //But on which side? vx can tell us\n        if (vx > 0) {\n          collision = \"left\"; //Move the rectangle out of the collision\n\n          r1.x = r1.x + overlapX;\n        } else {\n          collision = \"right\"; //Move the rectangle out of the collision\n\n          r1.x = r1.x - overlapX;\n        } //Bounce\n\n\n        if (bounce) {\n          r1.vx *= -1;\n          /*Alternative\r\n          //Find the bounce surface's vx and vy properties\r\n          var s = {};\r\n          s.vx = 0;\r\n          s.vy = r2.y - r2.y + r2.height;\r\n            //Bounce r1 off the surface\r\n          bounceOffSurface(r1, s);\r\n          */\n        }\n      }\n    } else {//No collision\n      }\n  } else {//No collision\n    } //Return the collision string. it will be either \"top\", \"right\",\n  //\"bottom\", or \"left\" depending on which side of r1 is touching r2.\n\n\n  return collision;\n}\n/*\r\nhitTestCircleRectangle\r\n----------------\r\n\r\nUse it to find out if a circular shape is touching a rectangular shape\r\nParameters: \r\na. A sprite object with `centerX`, `centerY`, `halfWidth` and `halfHeight` properties.\r\nb. A sprite object with `centerX`, `centerY`, `halfWidth` and `halfHeight` properties.\r\n\r\n*/\n\nfunction hitTestCircleRectangle(c1, r1) {\n  var global = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var region, collision, c1x, c1y, r1x, r1y; //Use either global or local coordinates\n\n  if (global) {\n    c1x = c1.gx;\n    c1y = c1.gy;\n    r1x = r1.gx;\n    r1y = r1.gy;\n  } else {\n    c1x = c1.x;\n    c1y = c1.y;\n    r1x = r1.x;\n    r1y = r1.y;\n  } //Is the circle above the rectangle's top edge?\n\n\n  if (c1y < r1y - r1.halfHeight) {\n    //If it is, we need to check whether it's in the \n    //top left, top center or top right\n    //(Increasing the size of the region by 2 pixels slightly weights\n    //the text in favor of a rectangle vs. rectangle collision test.\n    //This gives a more natural looking result with corner collisions\n    //when physics is added)\n    if (c1x < r1x - 1 - r1.halfWidth) {\n      region = \"topLeft\";\n    } else if (c1x > r1x + 1 + r1.halfWidth) {\n      region = \"topRight\";\n    } else {\n      region = \"topMiddle\";\n    }\n  } //The circle isn't above the top edge, so it might be\n  //below the bottom edge\n  else if (c1y > r1y + r1.halfHeight) {\n      //If it is, we need to check whether it's in the bottom left,\n      //bottom center, or bottom right\n      if (c1x < r1x - 1 - r1.halfWidth) {\n        region = \"bottomLeft\";\n      } else if (c1x > r1x + 1 + r1.halfWidth) {\n        region = \"bottomRight\";\n      } else {\n        region = \"bottomMiddle\";\n      }\n    } //The circle isn't above the top edge or below the bottom edge,\n    //so it must be on the left or right side\n    else {\n        if (c1x < r1x - r1.halfWidth) {\n          region = \"leftMiddle\";\n        } else {\n          region = \"rightMiddle\";\n        }\n      } //Is this the circle touching the flat sides\n  //of the rectangle?\n\n\n  if (region === \"topMiddle\" || region === \"bottomMiddle\" || region === \"leftMiddle\" || region === \"rightMiddle\") {\n    //Yes, it is, so do a standard rectangle vs. rectangle collision test\n    collision = hitTestRectangle(c1, r1, global);\n  } //The circle is touching one of the corners, so do a\n  //circle vs. point collision test\n  else {\n      var point = {};\n\n      switch (region) {\n        case \"topLeft\":\n          point.x = r1x;\n          point.y = r1y;\n          break;\n\n        case \"topRight\":\n          point.x = r1x + r1.width;\n          point.y = r1y;\n          break;\n\n        case \"bottomLeft\":\n          point.x = r1x;\n          point.y = r1y + r1.height;\n          break;\n\n        case \"bottomRight\":\n          point.x = r1x + r1.width;\n          point.y = r1y + r1.height;\n      } //Check for a collision between the circle and the point\n\n\n      collision = hitTestCirclePoint(c1, point, global);\n    } //Return the result of the collision.\n  //The return value will be `undefined` if there's no collision\n\n\n  if (collision) {\n    return region;\n  } else {\n    return collision;\n  }\n}\n/*\r\nhitTestCirclePoint\r\n------------------\r\n\r\nUse it to find out if a circular shape is touching a point\r\nParameters: \r\na. A sprite object with `centerX`, `centerY`, and `radius` properties.\r\nb. A point object with `x` and `y` properties.\r\n\r\n*/\n\nfunction hitTestCirclePoint(c1, point) {\n  var global = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  //A point is just a circle with a diameter of\n  //1 pixel, so we can cheat. All we need to do is an ordinary circle vs. circle\n  //Collision test. Just supply the point with the properties\n  //it needs\n  point.diameter = 1;\n  point.radius = 0.5;\n  point.centerX = point.x;\n  point.centerY = point.y;\n  point.gx = point.x;\n  point.gy = point.y;\n  return hitTestCircle(c1, point, global);\n}\n/*\r\ncircleRectangleCollision\r\n------------------------\r\n\r\nUse it to bounce a circular shape off a rectangular shape\r\nParameters: \r\na. A sprite object with `centerX`, `centerY`, `halfWidth` and `halfHeight` properties.\r\nb. A sprite object with `centerX`, `centerY`, `halfWidth` and `halfHeight` properties.\r\n\r\n*/\n\nfunction circleRectangleCollision(c1, r1) {\n  var bounce = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var global = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var region, collision, c1x, c1y, r1x, r1y; //Use either the global or local coordinates\n\n  if (global) {\n    c1x = c1.gx;\n    c1y = c1.gy;\n    r1x = r1.gx;\n    r1y = r1.gy;\n  } else {\n    c1x = c1.x;\n    c1y = c1.y;\n    r1x = r1.x;\n    r1y = r1.y;\n  } //Is the circle above the rectangle's top edge?\n\n\n  if (c1y < r1y - r1.halfHeight) {\n    //If it is, we need to check whether it's in the \n    //top left, top center or top right\n    if (c1x < r1x - 1 - r1.halfWidth) {\n      region = \"topLeft\";\n    } else if (c1x > r1x + 1 + r1.halfWidth) {\n      region = \"topRight\";\n    } else {\n      region = \"topMiddle\";\n    }\n  } //The circle isn't above the top edge, so it might be\n  //below the bottom edge\n  else if (c1y > r1y + r1.halfHeight) {\n      //If it is, we need to check whether it's in the bottom left,\n      //bottom center, or bottom right\n      if (c1x < r1x - 1 - r1.halfWidth) {\n        region = \"bottomLeft\";\n      } else if (c1x > r1x + 1 + r1.halfWidth) {\n        region = \"bottomRight\";\n      } else {\n        region = \"bottomMiddle\";\n      }\n    } //The circle isn't above the top edge or below the bottom edge,\n    //so it must be on the left or right side\n    else {\n        if (c1x < r1x - r1.halfWidth) {\n          region = \"leftMiddle\";\n        } else {\n          region = \"rightMiddle\";\n        }\n      } //Is this the circle touching the flat sides\n  //of the rectangle?\n\n\n  if (region === \"topMiddle\" || region === \"bottomMiddle\" || region === \"leftMiddle\" || region === \"rightMiddle\") {\n    //Yes, it is, so do a standard rectangle vs. rectangle collision test\n    collision = rectangleCollision(c1, r1, bounce, global);\n  } //The circle is touching one of the corners, so do a\n  //circle vs. point collision test\n  else {\n      var point = {};\n\n      switch (region) {\n        case \"topLeft\":\n          point.x = r1x;\n          point.y = r1y;\n          break;\n\n        case \"topRight\":\n          point.x = r1x + r1.width;\n          point.y = r1y;\n          break;\n\n        case \"bottomLeft\":\n          point.x = r1x;\n          point.y = r1y + r1.height;\n          break;\n\n        case \"bottomRight\":\n          point.x = r1x + r1.width;\n          point.y = r1y + r1.height;\n      } //Check for a collision between the circle and the point\n\n\n      collision = circlePointCollision(c1, point, bounce, global);\n    }\n\n  if (collision) {\n    return region;\n  } else {\n    return collision;\n  }\n}\n/*\r\ncirclePointCollision\r\n--------------------\r\n\r\nUse it to boucnce a circle off a point.\r\nParameters: \r\na. A sprite object with `centerX`, `centerY`, and `radius` properties.\r\nb. A point object with `x` and `y` properties.\r\n\r\n*/\n\nfunction circlePointCollision(c1, point) {\n  var bounce = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var global = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  //A point is just a circle with a diameter of\n  //1 pixel, so we can cheat. All we need to do is an ordinary circle vs. circle\n  //Collision test. Just supply the point with the properties\n  //it needs\n  point.diameter = 1;\n  point.radius = 0.5;\n  point.centerX = point.x;\n  point.centerY = point.y;\n  point.gx = point.x;\n  point.gy = point.y;\n  return circleCollision(c1, point, bounce, global);\n}\n/*\r\nbounceOffSurface\r\n----------------\r\n\r\nUse this to bounce an object off another object.\r\nParameters: \r\na. An object with `v.x` and `v.y` properties. This represents the object that is colliding\r\nwith a surface.\r\nb. An object with `x` and `y` properties. This represents the surface that the object\r\nis colliding into.\r\nThe first object can optionally have a mass property that's greater than 1. The mass will\r\nbe used to dampen the bounce effect.\r\n*/\n\nfunction bounceOffSurface(o, s) {\n  var dp1,\n      dp2,\n      p1 = {},\n      p2 = {},\n      bounce = {},\n      mass = o.mass || 1; //1. Calculate the collision surface's properties\n  //Find the surface vector's left normal\n\n  s.lx = s.y;\n  s.ly = -s.x; //Find its magnitude\n\n  s.magnitude = Math.sqrt(s.x * s.x + s.y * s.y); //Find its normalized values\n\n  s.dx = s.x / s.magnitude;\n  s.dy = s.y / s.magnitude; //2. Bounce the object (o) off the surface (s)\n  //Find the dot product between the object and the surface\n\n  dp1 = o.vx * s.dx + o.vy * s.dy; //Project the object's velocity onto the collision surface\n\n  p1.vx = dp1 * s.dx;\n  p1.vy = dp1 * s.dy; //Find the dot product of the object and the surface's left normal (s.lx and s.ly)\n\n  dp2 = o.vx * (s.lx / s.magnitude) + o.vy * (s.ly / s.magnitude); //Project the object's velocity onto the surface's left normal\n\n  p2.vx = dp2 * (s.lx / s.magnitude);\n  p2.vy = dp2 * (s.ly / s.magnitude); //Reverse the projection on the surface's left normal\n\n  p2.vx *= -1;\n  p2.vy *= -1; //Add up the projections to create a new bounce vector\n\n  bounce.x = p1.vx + p2.vx;\n  bounce.y = p1.vy + p2.vy; //Assign the bounce vector to the object's velocity\n  //with optional mass to dampen the effect\n\n  o.vx = bounce.x / mass;\n  o.vy = bounce.y / mass;\n}\n/*\r\nhit\r\n---\r\nA convenient universal collision function to test for collisions\r\nbetween rectangles, circles, and points.\r\n*/\n\n\nfunction hit(a, b) {\n  var react = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var bounce = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var global = arguments.length > 4 ? arguments[4] : undefined;\n  var extra = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : undefined;\n  var collision,\n      aIsASprite = a.parent !== undefined,\n      bIsASprite = b.parent !== undefined; //Check to make sure one of the arguments isn't an array\n\n  if (aIsASprite && b instanceof Array || bIsASprite && a instanceof Array) {\n    //If it is, check for a collision between a sprite and an array\n    spriteVsArray();\n  } else {\n    //If one of the arguments isn't an array, find out what type of\n    //collision check to run\n    collision = findCollisionType(a, b);\n    if (collision && extra) extra(collision);\n  } //Return the result of the collision.\n  //It will be `undefined` if there's no collision and `true` if \n  //there is a collision. `rectangleCollision` sets `collsision` to\n  //\"top\", \"bottom\", \"left\" or \"right\" depeneding on which side the\n  //collision is occuring on\n\n\n  return collision;\n\n  function findCollisionType(a, b) {\n    //Are `a` and `b` both sprites?\n    //(We have to check again if this function was called from\n    //`spriteVsArray`)\n    var aIsASprite = a.parent !== undefined;\n    var bIsASprite = b.parent !== undefined;\n\n    if (aIsASprite && bIsASprite) {\n      //Yes, but what kind of sprites?\n      if (a.diameter && b.diameter) {\n        //They're circles\n        return circleVsCircle(a, b);\n      } else if (a.diameter && !b.diameter) {\n        //The first one is a circle and the second is a rectangle\n        return circleVsRectangle(a, b);\n      } else {\n        //They're rectangles\n        return rectangleVsRectangle(a, b);\n      }\n    } //They're not both sprites, so what are they?\n    //Is `a` not a sprite and does it have x and y properties?\n    else if (bIsASprite && !(a.x === undefined) && !(a.y === undefined)) {\n        //Yes, so this is a point vs. sprite collision test\n        return hitTestPoint(a, b);\n      } else {\n        //The user is trying to test some incompatible objects\n        throw new Error(\"I'm sorry, \".concat(a, \" and \").concat(b, \" cannot be use together in a collision test.'\"));\n      }\n  }\n\n  function spriteVsArray() {\n    //If `a` happens to be the array, flip it around so that it becomes `b`\n    if (a instanceof Array) {\n      var _ref = [_b, _a],\n          _a = _ref[0],\n          _b = _ref[1];\n    } //Loop through the array in reverse\n\n\n    for (var i = b.length - 1; i >= 0; i--) {\n      var sprite = b[i];\n      collision = findCollisionType(a, sprite);\n      if (collision && extra) extra(collision, sprite);\n    }\n  }\n\n  function circleVsCircle(a, b) {\n    //If the circles shouldn't react to the collision,\n    //just test to see if they're touching\n    if (!react) {\n      return hitTestCircle(a, b);\n    } //Yes, the circles should react to the collision\n    else {\n        //Are they both moving?\n        if (a.vx + a.vy !== 0 && b.vx + b.vy !== 0) {\n          //Yes, they are both moving\n          //(moving circle collisions always bounce apart so there's\n          //no need for the third, `bounce`, argument)\n          return movingCircleCollision(a, b, global);\n        } else {\n          //No, they're not both moving\n          return circleCollision(a, b, bounce, global);\n        }\n      }\n  }\n\n  function rectangleVsRectangle(a, b) {\n    //If the rectangles shouldn't react to the collision, just\n    //test to see if they're touching\n    if (!react) {\n      return hitTestRectangle(a, b, global);\n    } else {\n      return rectangleCollision(a, b, bounce, global);\n    }\n  }\n\n  function circleVsRectangle(a, b) {\n    //If the rectangles shouldn't react to the collision, just\n    //test to see if they're touching\n    if (!react) {\n      return hitTestCircleRectangle(a, b, global);\n    } else {\n      return circleRectangleCollision(a, b, bounce, global);\n    }\n  }\n}\n\n//# sourceURL=webpack:///./src/js/library/collision.js?");

/***/ }),

/***/ "./src/js/library/display.js":
/*!***********************************!*\
  !*** ./src/js/library/display.js ***!
  \***********************************/
/*! exports provided: stage, makeCanvas, rectangle, circle, line, text, group, sprite, frame, frames, button, grid, filmstrip, remove, byLayer, buttons, draggableSprites, updateDragAndDrop, render, renderWithInterpolation, particles, emitter, particleEffect, tilingSprite, shakingSprites, shake, progressBar */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"stage\", function() { return stage; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"makeCanvas\", function() { return makeCanvas; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rectangle\", function() { return rectangle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"circle\", function() { return circle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"line\", function() { return line; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"text\", function() { return text; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"group\", function() { return group; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sprite\", function() { return sprite; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"frame\", function() { return frame; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"frames\", function() { return frames; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"button\", function() { return button; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"grid\", function() { return grid; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"filmstrip\", function() { return filmstrip; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"remove\", function() { return _remove; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"byLayer\", function() { return byLayer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"buttons\", function() { return buttons; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"draggableSprites\", function() { return draggableSprites; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"updateDragAndDrop\", function() { return updateDragAndDrop; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"render\", function() { return render; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"renderWithInterpolation\", function() { return renderWithInterpolation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"particles\", function() { return particles; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"emitter\", function() { return emitter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"particleEffect\", function() { return particleEffect; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"tilingSprite\", function() { return tilingSprite; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"shakingSprites\", function() { return shakingSprites; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"shake\", function() { return shake; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"progressBar\", function() { return progressBar; });\nfunction _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/* \r\ndisplay.js\r\n==========\r\n\r\nThis JavaScript file contains functions and objects useful for\r\ncreating and rendering canvas based sprites.\r\n\r\n*/\n//Dependencies\n//requestAnimationFrame polyfill\n//import \"../library/plugins/rAF\";\n//`hitTestPoint` needed for the Button class's `update` method\n//import {hitTestPoint} from \"../library/collision\"\n\n/*\r\nDisplayObject\r\n------\r\n\r\nThe sprites' parent class.\r\nIt contains all the properties shared by the sprites.\r\nIt shouldn't be instantiated, just extended.\r\n*/\nvar DisplayObject = /*#__PURE__*/function () {\n  function DisplayObject() {\n    _classCallCheck(this, DisplayObject);\n\n    //The sprite's position and size\n    this.x = 0;\n    this.y = 0;\n    this.width = 0;\n    this.height = 0; //Rotation, alpha, visible and scale properties\n\n    this.rotation = 0;\n    this.alpha = 1;\n    this.visible = true;\n    this.scaleX = 1;\n    this.scaleY = 1; //`pivotX` and `pivotY` let you set the sprite's axis of rotation\n\n    this.pivotX = 0.5;\n    this.pivotY = 0.5; //Add `vx` and `vy` (velocity) variables that will help us move the sprite\n\n    this.vx = 0;\n    this.vy = 0; //A \"private\" `_layer` property\n\n    this._layer = 0; //A `children` array on the sprite that will contain all the\n    //child sprites in this container\n\n    this.children = []; //The sprite's `parent` property \n\n    this.parent = undefined; //The sprite's `children` array\n    // this.children = [];\n    //Optional drop shadow properties.\n    //Set `shadow` to `true` if you want the sprite to display a\n    //shadow\n\n    this.shadow = false;\n    this.shadowColor = \"rgba(100, 100, 100, 0.5)\";\n    this.shadowOffsetX = 3;\n    this.shadowOffsetY = 3;\n    this.shadowBlur = 3; //Optional blend mode property\n\n    this.blendMode = undefined; //Properties for advanced features: \n    //Image states and animation\n\n    this.frames = [];\n    this.loop = true;\n    this._currentFrame = 0;\n    this.playing = false; //Can the sprite be dragged? \n\n    this._draggable = undefined; //Is the sprite circular? If it is, it will be given a `radius`\n    //and `diameter`\n\n    this._circular = false; //Is the sprite `interactive`? If it is, it can become click-able\n    //or touchable\n\n    this._interactive = false; //The sprite's previous x and y positions\n\n    this.previousX = 0;\n    this.previousY = 0;\n  }\n  /* Essentials */\n  //Global position\n\n\n  _createClass(DisplayObject, [{\n    key: \"addChild\",\n    //The `addChild` method lets you add sprites to this container\n    value: function addChild(sprite) {\n      //Remove the sprite from its current parent, if it has one, and\n      //the parent isn't already this object\n      if (sprite.parent) {\n        sprite.parent.removeChild(sprite);\n      } //Make this object the sprite's parent and\n      //add it to this object's `children` array\n\n\n      sprite.parent = this;\n      this.children.push(sprite);\n    } //The `removeChild` method lets you remove a sprite from its\n    //parent container\n\n  }, {\n    key: \"removeChild\",\n    value: function removeChild(sprite) {\n      if (sprite.parent === this) {\n        this.children.splice(this.children.indexOf(sprite), 1);\n      } else {\n        throw new Error(sprite + \"is not a child of \" + this);\n      }\n    } //Getters that return useful points on the sprite\n\n  }, {\n    key: \"setPosition\",\n    //A `setPosition` method to quickly set the sprite's x and y values\n    value: function setPosition(x, y) {\n      this.x = x;\n      this.y = y;\n    } //The `localBounds` and `globalBounds` methods return an object\n    //with `x`, `y`, `width`, and `height` properties that define\n    //the dimensions and position of the sprite. This is a convenience\n    //to help you set or test boundaries without having to know\n    //these numbers or request them specifically in your code.\n\n  }, {\n    key: \"putCenter\",\n    //The \"put\" methods help you position \n    //another sprite in and around this sprite. You can position\n    //sprites relative to this sprite's center, top, eight, bottom or\n    //left sides. The `xOffset` and `yOffset`\n    //arguments determine by how much the other sprite's position\n    //should be offset from the position. \n    //In all these methods, `b` is the second sprite that is being\n    //positioned relative to the first sprite (this one), `a`\n    //Center `b` inside `a`\n    value: function putCenter(b) {\n      var xOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var yOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var a = this;\n      b.x = a.x + a.halfWidth - b.halfWidth + xOffset;\n      b.y = a.y + a.halfHeight - b.halfHeight + yOffset;\n    } //Position `b` above `a`\n\n  }, {\n    key: \"putTop\",\n    value: function putTop(b) {\n      var xOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var yOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var a = this;\n      b.x = a.x + a.halfWidth - b.halfWidth + xOffset;\n      b.y = a.y - b.height + yOffset;\n    } //Position `b` to the right of `a`\n\n  }, {\n    key: \"putRight\",\n    value: function putRight(b) {\n      var xOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var yOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var a = this;\n      b.x = a.x + a.width + xOffset;\n      b.y = a.y + a.halfHeight - b.halfHeight + yOffset;\n    } //Position `b` below `a`\n\n  }, {\n    key: \"putBottom\",\n    value: function putBottom(b) {\n      var xOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var yOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var a = this;\n      b.x = a.x + a.halfWidth - b.halfWidth + xOffset;\n      b.y = a.y + a.height + yOffset;\n    } //Position `b` to the left of `a`\n\n  }, {\n    key: \"putLeft\",\n    value: function putLeft(b) {\n      var xOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var yOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var a = this;\n      b.x = a.x - b.width + xOffset;\n      b.y = a.y + a.halfHeight - b.halfHeight + yOffset;\n    } //Some extra conveniences for working with child sprites\n    //Swap the depth layer positions of two child sprites\n\n  }, {\n    key: \"swapChildren\",\n    value: function swapChildren(child1, child2) {\n      var index1 = this.children.indexOf(child1),\n          index2 = this.children.indexOf(child2);\n\n      if (index1 !== -1 && index2 !== -1) {\n        //Swap the indexes\n        child1.childIndex = index2;\n        child2.childIndex = index1; //Swap the array positions\n\n        this.children[index1] = child2;\n        this.children[index2] = child1;\n      } else {\n        throw new Error(\"Both objects must be a child of the caller \".concat(this));\n      }\n    } //`add` and `remove` let you add and remove many sprites at the same time\n\n  }, {\n    key: \"add\",\n    value: function add() {\n      var _this = this;\n\n      for (var _len = arguments.length, spritesToAdd = new Array(_len), _key = 0; _key < _len; _key++) {\n        spritesToAdd[_key] = arguments[_key];\n      }\n\n      spritesToAdd.forEach(function (sprite) {\n        return _this.addChild(sprite);\n      });\n    }\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      var _this2 = this;\n\n      for (var _len2 = arguments.length, spritesToRemove = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        spritesToRemove[_key2] = arguments[_key2];\n      }\n\n      spritesToRemove.forEach(function (sprite) {\n        return _this2.removeChild(sprite);\n      });\n    }\n    /* Advanced features */\n    //If the sprite has more than one frame, return the \n    //value of `_currentFrame`\n\n  }, {\n    key: \"gx\",\n    get: function get() {\n      if (this.parent) {\n        //The sprite's global x position is a combination of\n        //its local x value and its parent's global x value\n        return this.x + this.parent.gx;\n      } else {\n        return this.x;\n      }\n    }\n  }, {\n    key: \"gy\",\n    get: function get() {\n      if (this.parent) {\n        return this.y + this.parent.gy;\n      } else {\n        return this.y;\n      }\n    } //Depth layer\n\n  }, {\n    key: \"layer\",\n    get: function get() {\n      return this._layer;\n    },\n    set: function set(value) {\n      this._layer = value;\n\n      if (this.parent) {\n        //Sort the sprite’s parent’s `children` array so that sprites with a\n        //higher `layer` value are moved to the end of the array\n        this.parent.children.sort(function (a, b) {\n          return a.layer - b.layer;\n        });\n      }\n    }\n  }, {\n    key: \"halfWidth\",\n    get: function get() {\n      return this.width / 2;\n    }\n  }, {\n    key: \"halfHeight\",\n    get: function get() {\n      return this.height / 2;\n    }\n  }, {\n    key: \"centerX\",\n    get: function get() {\n      return this.x + this.halfWidth;\n    }\n  }, {\n    key: \"centerY\",\n    get: function get() {\n      return this.y + this.halfHeight;\n    }\n    /* Conveniences */\n    //A `position` getter. It returns an object with x and y properties\n\n  }, {\n    key: \"position\",\n    get: function get() {\n      return {\n        x: this.x,\n        y: this.y\n      };\n    }\n  }, {\n    key: \"localBounds\",\n    get: function get() {\n      return {\n        x: 0,\n        y: 0,\n        width: this.width,\n        height: this.height\n      };\n    }\n  }, {\n    key: \"globalBounds\",\n    get: function get() {\n      return {\n        x: this.gx,\n        y: this.gy,\n        width: this.gx + this.width,\n        height: this.gy + this.height\n      };\n    } //`empty` is a convenience property that will return `true` or\n    //`false` depending on whether or not this sprite's `children`\n    //array is empty\n\n  }, {\n    key: \"empty\",\n    get: function get() {\n      if (this.children.length === 0) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n  }, {\n    key: \"currentFrame\",\n    get: function get() {\n      return this._currentFrame;\n    } //The `circular` property lets you define whether a sprite\n    //should be interpreted as a circular object. If you set\n    //`circular` to `true`, the sprite is given `radius` and `diameter`\n    //properties. If you set `circular` to `false`, the `radius`\n    //and `diameter` properties are deleted from the sprite\n\n  }, {\n    key: \"circular\",\n    get: function get() {\n      return this._circular;\n    },\n    set: function set(value) {\n      //Give the sprite `diameter` and `radius` properties\n      //if `circular` is `true`\n      if (value === true && this._circular === false) {\n        Object.defineProperties(this, {\n          diameter: {\n            get: function get() {\n              return this.width;\n            },\n            set: function set(value) {\n              this.width = value;\n              this.height = value;\n            },\n            enumerable: true,\n            configurable: true\n          },\n          radius: {\n            get: function get() {\n              return this.halfWidth;\n            },\n            set: function set(value) {\n              this.width = value * 2;\n              this.height = value * 2;\n            },\n            enumerable: true,\n            configurable: true\n          }\n        }); //Set this sprite's `_circular` property to `true`\n\n        this._circular = true;\n      } //Remove the sprite's `diameter` and `radius` properties\n      //if `circular` is `false`\n\n\n      if (value === false && this._circular === true) {\n        delete this.diameter;\n        delete this.radius;\n        this._circular = false;\n      }\n    } //Is the sprite draggable by the pointer? If `draggable` is set\n    //to `true`, the sprite is added to a `draggableSprites`\n    //array. All the sprites in `draggableSprites` are updated each\n    //frame to check whether they're being dragged\n\n  }, {\n    key: \"draggable\",\n    get: function get() {\n      return this._draggable;\n    },\n    set: function set(value) {\n      if (value === true) {\n        //Push the sprite into the `draggableSprites` array\n        draggableSprites.push(this);\n        this._draggable = true;\n      } //If it's `false`, remove it from the `draggableSprites` array\n\n\n      if (value === false) {\n        //Splice the sprite from the `draggableSprites` array\n        draggableSprites.splice(draggableSprites.indexOf(this), 1);\n      }\n    } //Is the sprite interactive? If `interactive` is set to `true`,\n    //the sprite is run through the `makeInteractive` function.\n    //`makeInteractive` makes the sprite sensitive to pointer\n    //actions. It also adds the sprite to the `buttons` array,\n    //which is updated each frame\n\n  }, {\n    key: \"interactive\",\n    get: function get() {\n      return this._interactive;\n    },\n    set: function set(value) {\n      if (value === true) {\n        //Add interactive properties to the sprite\n        //so that it can act like a button\n        makeInteractive(this); //Add the sprite to the global `buttons` array so\n        //it can be updated each frame\n\n        buttons.push(this); //Set this sprite’s private `_interactive` property to `true`\n\n        this._interactive = true;\n      }\n\n      if (value === false) {\n        //Remove the sprite's reference from the \n        //`buttons` array so that it it's no longer affected\n        //by mouse and touch interactivity\n        buttons.splice(buttons.indexOf(this), 1);\n        this._interactive = false;\n      }\n    }\n  }]);\n\n  return DisplayObject;\n}();\n/*\r\nStage\r\n---------\r\n\r\nThe `stage` is the root display object     \r\n*/\n\n\nvar stage = new DisplayObject();\n/*\r\nmakeCanvas\r\n----------\r\n\r\nMake the canvas using default properties, like this:\r\n\r\n    let canvas = makeCanvas();\r\n    \r\nYou can then access the context as `canvas.ctx`.\r\n\r\nOptionally customize the canvas with a configuration object:\r\n\r\n    let canvas = makeCanvas({\r\n      width: 500,\r\n      height: 400,\r\n      border: \"none\",\r\n      backgroundColor: \"black\"\r\n    });\r\n*/\n\nfunction makeCanvas() {\n  var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 256;\n  var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 256;\n  var border = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"1px dashed black\";\n  var backgroundColor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"white\";\n  //Make the canvas element and add it to the DOM\n  var canvas = document.createElement(\"canvas\");\n  canvas.width = width;\n  canvas.height = height;\n  canvas.style.border = border;\n  canvas.style.backgroundColor = backgroundColor;\n  document.body.appendChild(canvas); //Create the context as a property of the canvas\n\n  canvas.ctx = canvas.getContext(\"2d\"); //Return the canvas\n\n  return canvas;\n}\n/*\r\nRectangle\r\n---------\r\n\r\nA Rectangle class\r\n*/\n\nvar Rectangle = /*#__PURE__*/function (_DisplayObject) {\n  _inherits(Rectangle, _DisplayObject);\n\n  var _super = _createSuper(Rectangle);\n\n  function Rectangle() {\n    var _this3;\n\n    var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 32;\n    var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 32;\n    var fillStyle = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"gray\";\n    var strokeStyle = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"none\";\n    var lineWidth = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    var x = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n    var y = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\n\n    _classCallCheck(this, Rectangle);\n\n    //Call the DisplayObject's constructor\n    _this3 = _super.call(this); //Assign the argument values to this sprite \n\n    Object.assign(_assertThisInitialized(_this3), {\n      width: width,\n      height: height,\n      fillStyle: fillStyle,\n      strokeStyle: strokeStyle,\n      lineWidth: lineWidth,\n      x: x,\n      y: y\n    }); //Add a `mask` property to enable optional masking\n\n    _this3.mask = false;\n    return _this3;\n  } //The `render` method explains how to draw the sprite\n\n\n  _createClass(Rectangle, [{\n    key: \"render\",\n    value: function render(ctx) {\n      ctx.strokeStyle = this.strokeStyle;\n      ctx.lineWidth = this.lineWidth;\n      ctx.fillStyle = this.fillStyle;\n      ctx.beginPath();\n      ctx.rect( //Draw the sprite around its `pivotX` and `pivotY` point\n      -this.width * this.pivotX, -this.height * this.pivotY, this.width, this.height);\n      if (this.strokeStyle !== \"none\") ctx.stroke();\n      if (this.fillStyle !== \"none\") ctx.fill();\n      if (this.mask && this.mask === true) ctx.clip();\n    }\n  }]);\n\n  return Rectangle;\n}(DisplayObject); //A higher level wrapper for the rectangle sprite\n\n\nfunction rectangle(width, height, fillStyle, strokeStyle, lineWidth, x, y) {\n  //Create the sprite\n  var sprite = new Rectangle(width, height, fillStyle, strokeStyle, lineWidth, x, y); //Add the sprite to the stage\n\n  stage.addChild(sprite); //Return the sprite to the main program\n\n  return sprite;\n}\n/*\r\nCircle\r\n------\r\n\r\nA Circle class\r\n*/\n\nvar Circle = /*#__PURE__*/function (_DisplayObject2) {\n  _inherits(Circle, _DisplayObject2);\n\n  var _super2 = _createSuper(Circle);\n\n  function Circle() {\n    var _this4;\n\n    var diameter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 32;\n    var fillStyle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"gray\";\n    var strokeStyle = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"none\";\n    var lineWidth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    var x = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    var y = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n\n    _classCallCheck(this, Circle);\n\n    //Call the DisplayObject's constructor\n    _this4 = _super2.call(this); //Enable `radius` and `diameter` properties\n\n    _this4.circular = true; //Assign the argument values to this sprite \n\n    Object.assign(_assertThisInitialized(_this4), {\n      diameter: diameter,\n      fillStyle: fillStyle,\n      strokeStyle: strokeStyle,\n      lineWidth: lineWidth,\n      x: x,\n      y: y\n    }); //Add a `mask` property to enable optional masking\n\n    _this4.mask = false;\n    return _this4;\n  } //The `render` method explains how to draw the sprite\n\n\n  _createClass(Circle, [{\n    key: \"render\",\n    value: function render(ctx) {\n      ctx.strokeStyle = this.strokeStyle;\n      ctx.lineWidth = this.lineWidth;\n      ctx.fillStyle = this.fillStyle;\n      ctx.beginPath();\n      ctx.arc(this.radius + -this.diameter * this.pivotX, this.radius + -this.diameter * this.pivotY, this.radius, 0, 2 * Math.PI, false);\n      if (this.strokeStyle !== \"none\") ctx.stroke();\n      if (this.fillStyle !== \"none\") ctx.fill();\n      if (this.mask && this.mask === true) ctx.clip();\n    }\n  }]);\n\n  return Circle;\n}(DisplayObject); //A higher level wrapper for the circle sprite\n\n\nfunction circle(diameter, fillStyle, strokeStyle, lineWidth, x, y) {\n  //Create the sprite\n  var sprite = new Circle(diameter, fillStyle, strokeStyle, lineWidth, x, y); //Add the sprite to the stage\n\n  stage.addChild(sprite); //Return the sprite to the main program\n\n  return sprite;\n}\n/*\r\nLine\r\n------\r\n\r\nA Line class\r\n*/\n\nvar Line = /*#__PURE__*/function (_DisplayObject3) {\n  _inherits(Line, _DisplayObject3);\n\n  var _super3 = _createSuper(Line);\n\n  function Line() {\n    var _this5;\n\n    var strokeStyle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"none\";\n    var lineWidth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var ax = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var ay = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    var bx = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 32;\n    var by = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 32;\n\n    _classCallCheck(this, Line);\n\n    //Call the DisplayObject's constructor\n    _this5 = _super3.call(this); //Assign the argument values to this sprite \n\n    Object.assign(_assertThisInitialized(_this5), {\n      strokeStyle: strokeStyle,\n      lineWidth: lineWidth,\n      ax: ax,\n      ay: ay,\n      bx: bx,\n      by: by\n    }); //The `lineJoin` style.\n    //Options are \"round\", \"mitre\" and \"bevel\".\n\n    _this5.lineJoin = \"round\";\n    return _this5;\n  } //The `render` method explains how to draw the sprite\n\n\n  _createClass(Line, [{\n    key: \"render\",\n    value: function render(ctx) {\n      ctx.strokeStyle = this.strokeStyle;\n      ctx.lineWidth = this.lineWidth;\n      ctx.lineJoin = this.lineJoin;\n      ctx.beginPath();\n      ctx.moveTo(this.ax, this.ay);\n      ctx.lineTo(this.bx, this.by);\n      if (this.strokeStyle !== \"none\") ctx.stroke();\n    }\n  }]);\n\n  return Line;\n}(DisplayObject); //A higher level wrapper for the line sprite\n\n\nfunction line(strokeStyle, lineWidth, ax, ay, bx, by) {\n  //Create the sprite\n  var sprite = new Line(strokeStyle, lineWidth, ax, ay, bx, by); //Add the sprite to the stage\n\n  stage.addChild(sprite); //Return the sprite to the main program\n\n  return sprite;\n}\n/*\r\nText\r\n------\r\n\r\nA Text class\r\n*/\n\nvar Text = /*#__PURE__*/function (_DisplayObject4) {\n  _inherits(Text, _DisplayObject4);\n\n  var _super4 = _createSuper(Text);\n\n  function Text() {\n    var _this6;\n\n    var content = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"Hello!\";\n    var font = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"12px sans-serif\";\n    var fillStyle = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"red\";\n    var x = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    var y = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n\n    _classCallCheck(this, Text);\n\n    //Call the DisplayObject's constructor\n    _this6 = _super4.call(this); //Assign the argument values to this sprite \n\n    Object.assign(_assertThisInitialized(_this6), {\n      content: content,\n      font: font,\n      fillStyle: fillStyle,\n      x: x,\n      y: y\n    }); //Set the default text baseline to \"top\"\n\n    _this6.textBaseline = \"top\"; //Set `strokeText` to \"none\"\n\n    _this6.strokeText = \"none\";\n    return _this6;\n  } //The `render` method explains how to draw the sprite\n\n\n  _createClass(Text, [{\n    key: \"render\",\n    value: function render(ctx) {\n      ctx.font = this.font;\n      ctx.strokeStyle = this.strokeStyle;\n      ctx.lineWidth = this.lineWidth;\n      ctx.fillStyle = this.fillStyle; //Measure the width and height of the text\n\n      if (this.width === 0) this.width = ctx.measureText(this.content).width;\n      if (this.height === 0) this.height = ctx.measureText(\"M\").width;\n      ctx.translate(-this.width * this.pivotX, -this.height * this.pivotY);\n      ctx.textBaseline = this.textBaseline;\n      ctx.fillText(this.content, 0, 0);\n      if (this.strokeText !== \"none\") ctx.strokeText();\n    }\n  }]);\n\n  return Text;\n}(DisplayObject); //A higher level wrapper for the line sprite\n\n\nfunction text(content, font, fillStyle, x, y) {\n  //Create the sprite\n  var sprite = new Text(content, font, fillStyle, x, y); //Add the sprite to the stage\n\n  stage.addChild(sprite); //Return the sprite to the main program\n\n  return sprite;\n}\n/*\r\nGroup\r\n------\r\n\r\nA Group class\r\n*/\n\nvar Group = /*#__PURE__*/function (_DisplayObject5) {\n  _inherits(Group, _DisplayObject5);\n\n  var _super5 = _createSuper(Group);\n\n  function Group() {\n    var _this7;\n\n    _classCallCheck(this, Group);\n\n    //Call the DisplayObject's constructor\n    _this7 = _super5.call(this); //Group all the sprites listed in the constructor arguments\n\n    for (var _len3 = arguments.length, spritesToGroup = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      spritesToGroup[_key3] = arguments[_key3];\n    }\n\n    spritesToGroup.forEach(function (sprite) {\n      return _this7.addChild(sprite);\n    });\n    return _this7;\n  } //Groups have custom `addChild` and `removeChild` methods that call\n  //a `calculateSize` method when any sprites are added or removed\n  //from the group\n  //\n\n\n  _createClass(Group, [{\n    key: \"addChild\",\n    value: function addChild(sprite) {\n      if (sprite.parent) {\n        sprite.parent.removeChild(sprite);\n      }\n\n      sprite.parent = this;\n      this.children.push(sprite); //Figure out the new size of the group\n\n      this.calculateSize();\n    }\n  }, {\n    key: \"removeChild\",\n    value: function removeChild(sprite) {\n      if (sprite.parent === this) {\n        this.children.splice(this.children.indexOf(sprite), 1); //Figure out the new size of the group\n\n        this.calculateSize();\n      } else {\n        throw new Error(\"\".concat(sprite, \" is not a child of \").concat(this));\n      }\n    }\n    /*\r\n     calculateSize() {\r\n    \n       //Calculate the width based on the size of the largest child\r\n       //that this sprite contains\r\n       if (this.children.length > 0) {\r\n    \n         //Some temporary variables to help track the new\r\n         //calculated width and height\r\n         let newWidth = 0,\r\n             newHeight = 0;\r\n    \n         //Find the width and height of the child sprites furthest\r\n         //from the top left corner of the group\r\n         this.children.forEach(child => {\r\n    \n           //Find child sprites that combined x value and width\r\n           //that's greater than the current value of `newWidth`\r\n           if (child.x + child.width > newWidth) {\r\n    \n             //The new width is a combination of the child's\r\n             //x position and its width\r\n             newWidth = child.x + child.width;\r\n           }\r\n           if (child.y + child.height > newHeight) {\r\n             newHeight = child.y + child.height;\r\n           }\r\n         }); \r\n    \n         //Apply the `newWidth` and `newHeight` to this sprite's width\r\n         //and height\r\n         this.width = newWidth;\r\n         this.height = newHeight;\r\n       }\r\n     }\r\n     */\n\n  }, {\n    key: \"calculateSize\",\n    value: function calculateSize() {\n      var _this8 = this;\n\n      //Calculate the width based on the size of the largest child\n      //that this sprite contains\n      if (this.children.length > 0) {\n        //Some temporary private variables to help track the new\n        //calculated width and height\n        this._newWidth = 0;\n        this._newHeight = 0; //Find the width and height of the child sprites furthest\n        //from the top left corner of the group\n\n        this.children.forEach(function (child) {\n          //Find child sprites that combined x value and width\n          //that's greater than the current value of `_newWidth`\n          if (child.x + child.width > _this8._newWidth) {\n            //The new width is a combination of the child's\n            //x position and its width\n            _this8._newWidth = child.x + child.width;\n          }\n\n          if (child.y + child.height > _this8._newHeight) {\n            _this8._newHeight = child.y + child.height;\n          }\n        }); //Apply the `_newWidth` and `_newHeight` to this sprite's width\n        //and height\n\n        this.width = this._newWidth;\n        this.height = this._newHeight;\n      }\n    }\n  }]);\n\n  return Group;\n}(DisplayObject); //A higher level wrapper for the group sprite\n\n\nfunction group() {\n  for (var _len4 = arguments.length, spritesToGroup = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n    spritesToGroup[_key4] = arguments[_key4];\n  }\n\n  //Create the sprite\n  var sprite = _construct(Group, spritesToGroup); //Add the sprite to the stage\n\n\n  stage.addChild(sprite); //Return the sprite to the main program\n\n  return sprite;\n}\n/*\r\nSprite\r\n---------\r\n\r\nA Sprite class to make sprites from images\r\n*/\n\nvar Sprite = /*#__PURE__*/function (_DisplayObject6) {\n  _inherits(Sprite, _DisplayObject6);\n\n  var _super6 = _createSuper(Sprite);\n\n  function Sprite(source) {\n    var _this9;\n\n    var x = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var y = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n    _classCallCheck(this, Sprite);\n\n    //Call the DisplayObject's constructor\n    _this9 = _super6.call(this); //Assign the argument values to this sprite \n\n    Object.assign(_assertThisInitialized(_this9), {\n      x: x,\n      y: y\n    }); //We need to figure out what the source is, and then use\n    //use that source data to display the sprite image correctly\n    //Is the source a JavaScript Image object?\n\n    if (source instanceof Image) {\n      _this9.createFromImage(source);\n    } //Is the source a tileset from a texture atlas?\n    //(It is if it has a `frame` property)\n    else if (source.frame) {\n        _this9.createFromAtlas(source);\n      } //If the source contains an `image` sub-property, this must\n      //be a `frame` object that's defining the rectangular area of an inner sub-image\n      //Use that sub-image to make the sprite. If it doesn't contain a\n      //`data` property, then it must be a single frame.\n      else if (source.image && !source.data) {\n          _this9.createFromTileset(source);\n        } //If the source contains an `image` sub-property\n        //and a `data` property, then it contains multiple frames\n        else if (source.image && source.data) {\n            _this9.createFromTilesetFrames(source);\n          } //Is the source an array? If so, what kind of array?\n          else if (source instanceof Array) {\n              if (source[0] && source[0].source) {\n                //The source is an array of frames on a texture atlas tileset\n                _this9.createFromAtlasFrames(source);\n              } //It must be an array of image objects\n              else if (source[0] instanceof Image) {\n                  _this9.createFromImages(source);\n                } //throw an error if the sources in the array aren't recognized\n                else {\n                    throw new Error(\"The image sources in \".concat(source, \" are not recognized\"));\n                  }\n            } //Throw an error if the source is something we can't interpret\n            else {\n                throw new Error(\"The image source \".concat(source, \" is not recognized\"));\n              }\n\n    return _this9;\n  }\n\n  _createClass(Sprite, [{\n    key: \"createFromImage\",\n    value: function createFromImage(source) {\n      //Throw an error if the source is not an Image object\n      if (!(source instanceof Image)) {\n        throw new Error(\"\".concat(source, \" is not an image object\"));\n      } else {\n        this.source = source;\n        this.sourceX = 0;\n        this.sourceY = 0;\n        this.width = source.width;\n        this.height = source.height;\n        this.sourceWidth = source.width;\n        this.sourceHeight = source.height;\n      }\n    }\n  }, {\n    key: \"createFromAtlas\",\n    value: function createFromAtlas(source) {\n      this.tilesetFrame = source;\n      this.source = this.tilesetFrame.source;\n      this.sourceX = this.tilesetFrame.frame.x;\n      this.sourceY = this.tilesetFrame.frame.y;\n      this.width = this.tilesetFrame.frame.w;\n      this.height = this.tilesetFrame.frame.h;\n      this.sourceWidth = this.tilesetFrame.frame.w;\n      this.sourceHeight = this.tilesetFrame.frame.h;\n    }\n  }, {\n    key: \"createFromTileset\",\n    value: function createFromTileset(source) {\n      //Throw an error if the source is not an image object\n      if (!(source.image instanceof Image)) {\n        throw new Error(\"\".concat(source.image, \" is not an image object\"));\n      } else {\n        this.source = source.image;\n        this.sourceX = source.x;\n        this.sourceY = source.y;\n        this.width = source.width;\n        this.height = source.height;\n        this.sourceWidth = source.width;\n        this.sourceHeight = source.height;\n      }\n    }\n  }, {\n    key: \"createFromTilesetFrames\",\n    value: function createFromTilesetFrames(source) {\n      //Throw an error if the source is not an Image object\n      if (!(source.image instanceof Image)) {\n        throw new Error(\"\".concat(source.image, \" is not an image object\"));\n      } else {\n        this.source = source.image;\n        this.frames = source.data; //Set the sprite to the first frame\n\n        this.sourceX = this.frames[0][0];\n        this.sourceY = this.frames[0][1];\n        this.width = source.width;\n        this.height = source.height;\n        this.sourceWidth = source.width;\n        this.sourceHeight = source.height;\n      }\n    }\n  }, {\n    key: \"createFromAtlasFrames\",\n    value: function createFromAtlasFrames(source) {\n      this.frames = source;\n      this.source = source[0].source;\n      this.sourceX = source[0].frame.x;\n      this.sourceY = source[0].frame.y;\n      this.width = source[0].frame.w;\n      this.height = source[0].frame.h;\n      this.sourceWidth = source[0].frame.w;\n      this.sourceHeight = source[0].frame.h;\n    }\n  }, {\n    key: \"createFromImages\",\n    value: function createFromImages(source) {\n      this.frames = source;\n      this.source = source[0];\n      this.sourceX = 0;\n      this.sourceY = 0;\n      this.width = source[0].width;\n      this.height = source[0].width;\n      this.sourceWidth = source[0].width;\n      this.sourceHeight = source[0].height;\n    } //Add a `gotoAndStop` method to go to a specific frame.\n\n  }, {\n    key: \"gotoAndStop\",\n    value: function gotoAndStop(frameNumber) {\n      if (this.frames.length > 0 && frameNumber < this.frames.length) {\n        //a. Frames made from tileset sub-images. \n        //If each frame is an array, then the frames were made from an\n        //ordinary Image object using the `frames` method\n        if (this.frames[0] instanceof Array) {\n          this.sourceX = this.frames[frameNumber][0];\n          this.sourceY = this.frames[frameNumber][1];\n        } //b. Frames made from texture atlas frames.\n        //If each frame isn't an array, and it has a sub-object called `frame`,\n        //then the frame must be a texture atlas id name.\n        //In that case, get the source position from the atlas's `frame` object.\n        else if (this.frames[frameNumber].frame) {\n            this.sourceX = this.frames[frameNumber].frame.x;\n            this.sourceY = this.frames[frameNumber].frame.y;\n            this.sourceWidth = this.frames[frameNumber].frame.w;\n            this.sourceHeight = this.frames[frameNumber].frame.h;\n            this.width = this.frames[frameNumber].frame.w;\n            this.height = this.frames[frameNumber].frame.h;\n          } //c. Frames made from individual image objects.\n          //If neither of the above are true, then each frame must be\n          //an individual Image object\n          else {\n              this.source = this.frames[frameNumber];\n              this.sourceX = 0;\n              this.sourceY = 0;\n              this.width = this.source.width;\n              this.height = this.source.height;\n              this.sourceWidth = this.source.width;\n              this.sourceHeight = this.source.height;\n            } //Set the `_currentFrame` value to the chosen frame\n\n\n        this._currentFrame = frameNumber;\n      } //Throw an error if this sprite doesn't contain any frames\n      else {\n          throw new Error(\"Frame number \".concat(frameNumber, \" does not exist\"));\n        }\n    } //The `render` method explains how to draw the sprite\n\n  }, {\n    key: \"render\",\n    value: function render(ctx) {\n      ctx.drawImage(this.source, this.sourceX, this.sourceY, this.sourceWidth, this.sourceHeight, -this.width * this.pivotX, -this.height * this.pivotY, this.width, this.height);\n    }\n  }]);\n\n  return Sprite;\n}(DisplayObject); //A higher level wrapper\n\n\nfunction sprite(source, x, y) {\n  //Create the sprite\n  var sprite = new Sprite(source, x, y); //Add the state player (to control animation) if the\n  //sprite has multiple frames\n\n  if (sprite.frames.length > 0) addStatePlayer(sprite); //Add the sprite to the stage\n\n  stage.addChild(sprite); //Return the sprite to the main program\n\n  return sprite;\n} //### frame\n//The `frame` method returns and object that defines\n//in the position and size of a sub-image in a tileset. Use it if you\n//want to create a sprite from a sub-image inside an Image object.\n//arguments: sourceString, xPostionOfSubImage, yPositionOfSubImage,\n//widthOfSubImage, heightOfSubImage.\n\nfunction frame(source, x, y, width, height) {\n  var o = {};\n  o.image = source;\n  o.x = x;\n  o.y = y;\n  o.width = width;\n  o.height = height;\n  return o;\n}\n; //### frames\n//The `frames` function returns and object that defines\n//the position and size of many sub-images in a single tileset image.\n//arguments: sourceString, 2DArrayOfXandYPositions, widthOfSubImage,\n//heightOfSubImage.\n\nfunction frames(source, arrayOfPositions, width, height) {\n  var o = {};\n  o.image = source;\n  o.data = arrayOfPositions;\n  o.width = width;\n  o.height = height;\n  return o;\n}\n;\n/*\r\nButton\r\n---------\r\n\r\nA Button class to help make sprites with three\r\ninteractive frames: op, over and down\r\n\r\n*/\n\nvar Button = /*#__PURE__*/function (_Sprite) {\n  _inherits(Button, _Sprite);\n\n  var _super7 = _createSuper(Button);\n\n  function Button(source) {\n    var _this10;\n\n    var x = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var y = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n    _classCallCheck(this, Button);\n\n    _this10 = _super7.call(this, source, x, y);\n    _this10.interactive = true;\n    return _this10;\n  }\n\n  return Button;\n}(Sprite); //A higher level wrapper\n\n\nfunction button(source, x, y) {\n  var sprite = new Button(source, x, y);\n  stage.addChild(sprite);\n  return sprite;\n}\n/*\r\ngrid\r\n----\r\n\r\nHelps you to automatically create a grid of sprites. `grid` returns a\r\n`group` sprite object that contains a sprite for every cell in the\r\ngrid. You can define the rows and columns in the grid, whether or\r\nnot the sprites should be centered inside each cell, or what their offset from the\r\ntop left corner of each cell should be. Supply a function that\r\nreturns the sprite that you want to make for each cell. You can\r\nsupply an optional final function that runs any extra code after\r\neach sprite has been created. Here's the format for creating a grid:\r\n\r\n    gridGroup = grid(\r\n\r\n      //Set the grid's properties\r\n      columns, rows, cellWidth, cellHeight,\r\n      areSpirtesCentered?, xOffset, yOffset,\r\n\r\n      //A function that returns a sprite\r\n      () => g.circle(16, \"blue\"),\r\n\r\n      //An optional final function that runs some extra code\r\n      () => console.log(\"extra!\")\r\n    );\r\n*/\n\nfunction grid() {\n  var columns = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  var rows = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var cellWidth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 32;\n  var cellHeight = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 32;\n  var centerCell = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  var xOffset = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n  var yOffset = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\n  var makeSprite = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : undefined;\n  var extra = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : undefined;\n  //Create an empty group called `container`. This `container`\n  //group is what the function returns back to the main program.\n  //All the sprites in the grid cells will be added\n  //as children to this container\n  var container = group(); //The `create` method plots the grid\n\n  var createGrid = function createGrid() {\n    //Figure out the number of cells in the grid\n    var length = columns * rows; //Create a sprite for each cell\n\n    for (var i = 0; i < length; i++) {\n      //Figure out the sprite's x/y placement in the grid\n      var x = i % columns * cellWidth,\n          y = Math.floor(i / columns) * cellHeight; //Use the `makeSprite` function supplied in the constructor\n      //to make a sprite for the grid cell\n\n      var _sprite = makeSprite(); //Add the sprite to the `container`\n\n\n      container.addChild(_sprite); //Should the sprite be centered in the cell?\n      //No, it shouldn't be centered\n\n      if (!centerCell) {\n        _sprite.x = x + xOffset;\n        _sprite.y = y + yOffset;\n      } //Yes, it should be centered\n      else {\n          _sprite.x = x + cellWidth / 2 - _sprite.halfWidth + xOffset;\n          _sprite.y = y + cellHeight / 2 - _sprite.halfHeight + yOffset;\n        } //Run any optional extra code. This calls the\n      //`extra` function supplied by the constructor\n\n\n      if (extra) extra(_sprite);\n    }\n  }; //Run the `createGrid` method\n\n\n  createGrid(); //Return the `container` group back to the main program\n\n  return container;\n}\n/*\r\nfilmstrip\r\n---------\r\n\r\nIf you have a complex animation in a single image, you can use the\r\n`filmstrip` method to automatically create an array of x,y\r\ncoordinates for each animation frame.\r\n`filmstrip` arguments:\r\nimageName, frameWidth, frameHeight, spacing\r\n(The last `spacing` argument should be included if there's any\r\ndefault spacing (padding) around tileset images.)\r\n*/\n\nfunction filmstrip(image, frameWidth, frameHeight) {\n  var spacing = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  //An array to store the x and y positions of each frame\n  var positions = []; //Find out how many columns and rows there are in the image\n\n  var columns = image.width / frameWidth,\n      rows = image.height / frameHeight; //Find the total number of frames\n\n  var numberOfFrames = columns * rows;\n\n  for (var i = 0; i < numberOfFrames; i++) {\n    //Find the correct row and column for each frame\n    //and figure out its x and y position\n    var x = i % columns * frameWidth,\n        y = Math.floor(i / columns) * frameHeight; //Compensate for any optional spacing (padding) around the frames if\n    //there is any. This bit of code accumulates the spacing offsets from the\n    //left side of the tileset and adds them to the current tile's position\n\n    if (spacing && spacing > 0) {\n      x += spacing + spacing * i % columns;\n      y += spacing + spacing * Math.floor(i / columns);\n    } //Add the x and y value of each frame to the `positions` array\n\n\n    positions.push([x, y]);\n  } //Create and return the animation frames using the `frames` method\n\n\n  return frames(image, positions, frameWidth, frameHeight);\n}\n;\n/*\r\nremove\r\n-------\r\n\r\nA convenience function to remove a sprite from a game.\r\n\r\n    remove(spriteName);\r\n\r\nYou can remove more than one sprite at a time like this:\r\n\r\n   remove(spriteOne, spriteTwo, spriteThree);\r\n\r\n*/\n\nfunction _remove() {\n  for (var _len5 = arguments.length, spritesToRemove = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n    spritesToRemove[_key5] = arguments[_key5];\n  }\n\n  spritesToRemove.forEach(function (sprite) {\n    sprite.parent.removeChild(sprite);\n  });\n}\n/*\r\nsort functions\r\n--------------\r\n*/\n\n\n\nfunction byLayer(a, b) {\n  //return a.layer - b.layer;\n  if (a.layer < b.layer) {\n    return -1;\n  } else if (a.layer > b.layer) {\n    return 1;\n  } else {\n    return 1;\n  }\n}\n/*\r\nbuttons\r\n-------\r\n\r\nAn array to store all the interactive sprites, including buttons\r\n*/\n\nvar buttons = [];\n/*\r\n\r\nmakeInteractive\r\n---------------\r\n\r\nThe `makeInteractive` function lets you assign `press`, `release`, `over`, `tap`\r\nand `out` actions to sprites. It also tells you the pointer's state of interaction with the sprite.\r\n`makeInteractive` is called on a sprite when a sprite's\r\n`interactive` property is set to `true`.\r\n\r\n*/\n\nfunction makeInteractive(o) {\n  //The `press`,`release`, `over`, `out` and `tap` methods. They're `undefined`\n  //for now, but they can be defined in the game program\n  o.press = o.press || undefined;\n  o.release = o.release || undefined;\n  o.over = o.over || undefined;\n  o.out = o.out || undefined;\n  o.tap = o.tap || undefined; //The `state` property tells you the button's\n  //current state. Set its initial state to \"up\"\n\n  o.state = \"up\"; //The `action` property tells you whether its being pressed or\n  //released\n\n  o.action = \"\"; //The `pressed` and `hoverOver` Booleans are mainly for internal\n  //use in this code to help figure out the correct state.\n  //`pressed` is a Boolean that helps track whether or not\n  //the sprite has been pressed down\n\n  o.pressed = false; //`hoverOver` is a Boolean which checks whether the pointer\n  //has hovered over the sprite\n\n  o.hoverOver = false; //The `update` method will be called each frame \n  //inside the game loop\n\n  o.update = function (pointer, canvas) {\n    //Figure out if the pointer is touching the sprite\n    var hit = pointer.hitTestSprite(o); //1. Figure out the current state\n\n    if (pointer.isUp) {\n      //Up state\n      o.state = \"up\"; //Show the first image state frame, if this is a `Button` sprite\n\n      if (o instanceof Button) o.gotoAndStop(0);\n    } //If the pointer is touching the sprite, figure out\n    //if the over or down state should be displayed\n\n\n    if (hit) {\n      //Over state\n      o.state = \"over\"; //Show the second image state frame if this sprite has\n      //3 frames and it's a `Button` sprite\n\n      if (o.frames && o.frames.length === 3 && o instanceof Button) {\n        o.gotoAndStop(1);\n      } //Down state\n\n\n      if (pointer.isDown) {\n        o.state = \"down\"; //Show the third frame if this sprite is a `Button` sprite and it\n        //has only three frames, or show the second frame if it\n        //only has two frames\n\n        if (o instanceof Button) {\n          if (o.frames.length === 3) {\n            o.gotoAndStop(2);\n          } else {\n            o.gotoAndStop(1);\n          }\n        }\n      }\n    } //Perform the correct interactive action\n    //a. Run the `press` method if the sprite state is \"down\" and\n    //the sprite hasn't already been pressed\n\n\n    if (o.state === \"down\") {\n      if (!o.pressed) {\n        if (o.press) o.press();\n        o.pressed = true;\n        o.action = \"pressed\";\n      }\n    } //b. Run the `release` method if the sprite state is \"over\" and\n    //the sprite has been pressed\n\n\n    if (o.state === \"over\") {\n      if (o.pressed) {\n        if (o.release) o.release();\n        o.pressed = false;\n        o.action = \"released\"; //If the pointer was tapped and the user assigned a `tap`\n        //method, call the `tap` method\n\n        if (pointer.tapped && o.tap) o.tap();\n      } //Run the `over` method if it has been assigned\n\n\n      if (!o.hoverOver) {\n        if (o.over) o.over();\n        o.hoverOver = true;\n      }\n    } //c. Check whether the pointer has been released outside\n    //the sprite's area. If the button state is \"up\" and it's\n    //already been pressed, then run the `release` method.\n\n\n    if (o.state === \"up\") {\n      if (o.pressed) {\n        if (o.release) o.release();\n        o.pressed = false;\n        o.action = \"released\";\n      } //Run the `out` method if it has been assigned\n\n\n      if (o.hoverOver) {\n        if (o.out) o.out();\n        o.hoverOver = false;\n      }\n    }\n  };\n}\n/*\r\ndraggableSprites\r\n----------------\r\n\r\nAn array to store all the interactive sprites, including buttons\r\n*/\n\n\nvar draggableSprites = [];\n/*\r\nupdateDragAndDrop\r\n-------\r\n\r\nA function that enables drag and drop for sprites\r\n\r\n*/\n\nfunction updateDragAndDrop(pointer, canvas) {\n  var dragSprite = null,\n      dragOffsetX = 0,\n      dragOffsetY = 0;\n\n  if (pointer.isDown) {\n    //Capture the co-ordinates at which the pointer was\n    //pressed down and find out if it's touching a sprite\n    if (dragSprite === null) {\n      //Loop through the draggable sprites in reverse to start searching at the bottom of the stack\n      for (var i = draggableSprites.length - 1; i > -1; i--) {\n        var _sprite2 = draggableSprites[i]; //Check for a collision with the pointer using `hitTestPoint`\n\n        if (pointer.hitTestSprite(_sprite2) && _sprite2.draggable) {\n          //Calculate the difference between the pointer's\n          //position and the sprite's position\n          dragOffsetX = pointer.x - _sprite2.gx;\n          dragOffsetY = pointer.y - _sprite2.gy; //Set the sprite as the pointer's `dragSprite` property\n\n          dragSprite = _sprite2; //The next two lines re-order the `sprites` array so that the\n          //selected sprite is displayed above all the others.\n          //First, splice the sprite out of its current position in\n          //its parent's `children` array\n\n          var children = _sprite2.parent.children;\n          children.splice(children.indexOf(_sprite2), 1); //Next, push the `dragSprite` to the end of its `children` array so that it's\n          //displayed last, above all the other sprites\n\n          children.push(_sprite2);\n          break;\n        }\n      }\n    } else {\n      //If the pointer is down and it has a `dragSprite`, make the sprite follow the pointer's\n      //position, with the calculated offset\n      dragSprite.x = pointer.x - dragOffsetX;\n      dragSprite.y = pointer.y - dragOffsetY;\n    }\n  } //If the pointer is up, drop the `dragSprite` by setting it to `null`\n\n\n  if (pointer.isUp) {\n    dragSprite = null;\n  } //Change the mouse arrow pointer to a hand if it's over a\n  //sprite\n\n\n  draggableSprites.some(function (sprite) {\n    if (pointer.hitTestSprite(sprite) && sprite.draggable) {\n      canvas.style.cursor = \"pointer\";\n      return true;\n    } else {\n      canvas.style.cursor = \"auto\";\n      return false;\n    }\n  });\n}\n/*\r\nrender\r\n-------\r\n\r\nA render function that displays all the sprites on the canvas.\r\nUse it inside a game loop to render the sprites like this:\r\n\r\n    render(canvasContext);\r\n\r\n*/\n\nfunction render(canvas) {\n  //Get a reference to the context\n  var ctx = canvas.ctx; //Clear the canvas\n\n  ctx.clearRect(0, 0, canvas.width, canvas.height); //Loop through each sprite object in the stage's `children` array\n\n  stage.children.forEach(function (sprite) {\n    //Display a sprite \n    displaySprite(sprite);\n  });\n\n  function displaySprite(sprite) {\n    //Only display the sprite if it's visible\n    //and within the area of the canvas\n    if (sprite.visible && sprite.gx < canvas.width + sprite.width && sprite.gx + sprite.width >= -sprite.width && sprite.gy < canvas.height + sprite.height && sprite.gy + sprite.height >= -sprite.height) {\n      //Save the canvas's present state\n      ctx.save(); //Shift the canvas to the center of the sprite's position\n\n      ctx.translate(sprite.x + sprite.width * sprite.pivotX, sprite.y + sprite.height * sprite.pivotY); //Set the sprite's `rotation`, `alpha` and `scale`\n\n      ctx.rotate(sprite.rotation);\n      ctx.globalAlpha = sprite.alpha * sprite.parent.alpha;\n      ctx.scale(sprite.scaleX, sprite.scaleY); //Display the sprite's optional drop shadow\n\n      if (sprite.shadow) {\n        ctx.shadowColor = sprite.shadowColor;\n        ctx.shadowOffsetX = sprite.shadowOffsetX;\n        ctx.shadowOffsetY = sprite.shadowOffsetY;\n        ctx.shadowBlur = sprite.shadowBlur;\n      } //Display the optional blend mode\n\n\n      if (sprite.blendMode) ctx.globalCompositeOperation = sprite.blendMode; //Use the sprite's own `render` method to draw the sprite\n\n      if (sprite.render) sprite.render(ctx); //If the sprite contains child sprites in its\n      //`children` array, display them by recursively calling this very same\n      //`displaySprite` function again\n\n      if (sprite.children && sprite.children.length > 0) {\n        //Reset the context back to the parent sprite's top left corner,\n        //relative to the pivot point\n        ctx.translate(-sprite.width * sprite.pivotX, -sprite.height * sprite.pivotY); //Loop through the parent sprite's children\n\n        sprite.children.forEach(function (child) {\n          //display the child\n          displaySprite(child);\n        });\n      } //Restore the canvas to its previous state\n\n\n      ctx.restore();\n    }\n  }\n}\n/*\r\nrenderWithInterpolation\r\n-------\r\n\r\nA render function that displays all the sprites on the canvas.\r\nIt's the same as the ordinary `render` function, but interpolates the\r\nsprite positions for use with a fixed-timestep-variable-render game loop.\r\nUse it inside a game loop to render the sprites like this:\r\n\r\n    renderWithInterpolation(canvasContext, lagOffset);\r\n\r\n*/\n\nfunction renderWithInterpolation(canvas, lagOffset) {\n  //Get a reference to the context\n  var ctx = canvas.ctx; //Clear the canvas\n\n  ctx.clearRect(0, 0, canvas.width, canvas.height); //Loop through each sprite object in the stage's `children` array\n\n  stage.children.forEach(function (sprite) {\n    //Display a sprite \n    displaySprite(sprite);\n  });\n\n  function displaySprite(sprite) {\n    //Only display the sprite if it's visible\n    //and within the area of the canvas\n    if (sprite.visible && sprite.gx < canvas.width + sprite.width && sprite.gx + sprite.width > -sprite.width && sprite.gy < canvas.height + sprite.height && sprite.gy + sprite.height > -sprite.height) {\n      //Save the canvas's present state\n      ctx.save(); //Interpolation\n\n      if (sprite.previousX !== undefined) {\n        sprite.renderX = (sprite.x - sprite.previousX) * lagOffset + sprite.previousX;\n      } else {\n        sprite.renderX = sprite.x;\n      }\n\n      if (sprite.previousY !== undefined) {\n        sprite.renderY = (sprite.y - sprite.previousY) * lagOffset + sprite.previousY;\n      } else {\n        sprite.renderY = sprite.y;\n      } //Draw the sprite at its interpolated position\n\n\n      ctx.translate(sprite.renderX + sprite.width * sprite.pivotX, sprite.renderY + sprite.height * sprite.pivotY); //Set the sprite's `rotation`, `alpha` and `scale`\n\n      ctx.rotate(sprite.rotation);\n      ctx.globalAlpha = sprite.alpha * sprite.parent.alpha;\n      ctx.scale(sprite.scaleX, sprite.scaleY); //Display the sprite's optional drop shadow\n\n      if (sprite.shadow) {\n        ctx.shadowColor = sprite.shadowColor;\n        ctx.shadowOffsetX = sprite.shadowOffsetX;\n        ctx.shadowOffsetY = sprite.shadowOffsetY;\n        ctx.shadowBlur = sprite.shadowBlur;\n      } //Display the optional blend mode\n\n\n      if (sprite.blendMode) ctx.globalCompositeOperation = sprite.blendMode; //Use the sprite's own `render` method to draw the sprite\n\n      if (sprite.render) sprite.render(ctx); //If the sprite contains child sprites in its\n      //`children` array, display them by recursively calling this very same\n      //`displaySprite` function again\n\n      if (sprite.children && sprite.children.length > 0) {\n        //Reset the context back to the parent sprite's top left corner,\n        //relative to the pivot point\n        ctx.translate(-sprite.width * sprite.pivotX, -sprite.height * sprite.pivotY); //Loop through the parent sprite's children\n\n        sprite.children.forEach(function (child) {\n          //display the child\n          displaySprite(child);\n        });\n      } //Restore the canvas to its previous state\n\n\n      ctx.restore();\n    }\n  }\n}\n/*\r\naddStatePlayer\r\n-------------\r\n\r\n`addStatePlayer` adds a state manager and keyframe animation player for\r\nsprites with more than one frame. Its called automatically when\r\n`sprite`s are created.\r\n\r\n*/\n\nfunction addStatePlayer(sprite) {\n  var frameCounter = 0,\n      numberOfFrames = 0,\n      startFrame = 0,\n      endFrame = 0,\n      timerInterval = undefined; //playing = false;\n  //The `show` function (to display static states.)\n\n  function show(frameNumber) {\n    //Reset any possible previous animations\n    reset(); //Find the new state on the sprite.\n\n    sprite.gotoAndStop(frameNumber);\n  } //The `play` function plays all the sprites frames\n\n\n  function play() {\n    if (!sprite.playing) {\n      playSequence([0, sprite.frames.length - 1]);\n    }\n  } //The `stop` function stops the animation at the current frame\n\n\n  function stop() {\n    if (sprite.playing) {\n      reset();\n      sprite.gotoAndStop(sprite.currentFrame);\n    }\n  } //The `playSequence` function, to play a sequence of frames.\n\n\n  function playSequence(sequenceArray) {\n    //Reset any possible previous animations\n    reset(); //Figure out how many frames there are in the range\n\n    startFrame = sequenceArray[0];\n    endFrame = sequenceArray[1];\n    numberOfFrames = endFrame - startFrame; //Compensate for two edge cases:\n    //1. If the `startFrame` happens to be `0`\n\n    if (startFrame === 0) {\n      numberOfFrames += 1;\n      frameCounter += 1;\n    } //2. If only a two-frame sequence was provided\n\n\n    if (numberOfFrames === 1) {\n      numberOfFrames = 2;\n      frameCounter += 1;\n    }\n\n    ; //Calculate the frame rate. Set the default fps to 12\n\n    if (!sprite.fps) sprite.fps = 12;\n    var frameRate = 1000 / sprite.fps; //Set the sprite to the starting frame\n\n    sprite.gotoAndStop(startFrame); //If the state isn't already playing, start it\n\n    if (!sprite.playing) {\n      timerInterval = setInterval(advanceFrame.bind(this), frameRate);\n      sprite.playing = true;\n    }\n  } //`advanceFrame` is called by `setInterval` to display the next frame\n  //in the sequence based on the `frameRate`. When frame sequence\n  //reaches the end, it will either stop it or loop it\n\n\n  function advanceFrame() {\n    //Advance the frame if `frameCounter` is less than\n    //the state's total frames\n    if (frameCounter < numberOfFrames) {\n      //Advance the frame\n      sprite.gotoAndStop(sprite.currentFrame + 1); //Update the frame counter\n\n      frameCounter += 1; //If we've reached the last frame and `loop`\n      //is `true`, then start from the first frame again\n    } else {\n      if (sprite.loop) {\n        sprite.gotoAndStop(startFrame);\n        frameCounter = 1;\n      }\n    }\n  }\n\n  function reset() {\n    //Reset `playing` to `false`, set the `frameCounter` to 0,\n    //and clear the `timerInterval`\n    if (timerInterval !== undefined && sprite.playing === true) {\n      sprite.playing = false;\n      frameCounter = 0;\n      startFrame = 0;\n      endFrame = 0;\n      numberOfFrames = 0;\n      clearInterval(timerInterval);\n    }\n  } //Add the `show`, `play`, `stop` and `playSequence` methods to the sprite.\n\n\n  sprite.show = show;\n  sprite.play = play;\n  sprite.stop = stop; //sprite.playing = playing;\n\n  sprite.playSequence = playSequence;\n}\n/*\r\nparticles\r\n---------\r\n\r\nAn array to store all the game's particles. The game loop needs to call the \r\n`update` function on each particle in the array on every frame\r\n*/\n\n\nvar particles = [];\n/*\r\nemitter\r\n-------\r\n\r\nA particle emitter\r\n*/\n\nfunction emitter(interval, particleFunction) {\n  var emitter = {},\n      timerInterval = undefined;\n  emitter.playing = false;\n\n  function play() {\n    if (!emitter.playing) {\n      particleFunction();\n      timerInterval = setInterval(emitParticle.bind(this), interval);\n      emitter.playing = true;\n    }\n  }\n\n  function stop() {\n    if (emitter.playing) {\n      clearInterval(timerInterval);\n      emitter.playing = false;\n    }\n  }\n\n  function emitParticle() {\n    particleFunction();\n  }\n\n  emitter.play = play;\n  emitter.stop = stop;\n  return emitter;\n}\n/*\r\nparticleEffect\r\n-----\r\n\r\nA particle stream effect\r\n\r\n*/\n\nfunction particleEffect() {\n  var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var spriteFunction = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {\n    return circle(10, \"red\");\n  };\n  var numberOfParticles = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 10;\n  var gravity = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n  var randomSpacing = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n  var minAngle = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\n  var maxAngle = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 6.28;\n  var minSize = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 4;\n  var maxSize = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : 16;\n  var minSpeed = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : 0.1;\n  var maxSpeed = arguments.length > 11 && arguments[11] !== undefined ? arguments[11] : 1;\n  var minScaleSpeed = arguments.length > 12 && arguments[12] !== undefined ? arguments[12] : 0.01;\n  var maxScaleSpeed = arguments.length > 13 && arguments[13] !== undefined ? arguments[13] : 0.05;\n  var minAlphaSpeed = arguments.length > 14 && arguments[14] !== undefined ? arguments[14] : 0.02;\n  var maxAlphaSpeed = arguments.length > 15 && arguments[15] !== undefined ? arguments[15] : 0.02;\n  var minRotationSpeed = arguments.length > 16 && arguments[16] !== undefined ? arguments[16] : 0.01;\n  var maxRotationSpeed = arguments.length > 17 && arguments[17] !== undefined ? arguments[17] : 0.03;\n\n  //`randomFloat` and `randomInt` helper functions\n  var randomFloat = function randomFloat(min, max) {\n    return min + Math.random() * (max - min);\n  },\n      randomInt = function randomInt(min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n  }; //An array to store the angles\n\n\n  var angles = []; //A variable to store the current particle's angle\n\n  var angle; //Figure out by how many radians each particle should be separated\n\n  var spacing = (maxAngle - minAngle) / (numberOfParticles - 1); //Create an angle value for each particle and push that\n  //value into the `angles` array\n\n  for (var i = 0; i < numberOfParticles; i++) {\n    //If `randomSpacing` is `true`, give the particle any angle\n    //value between `minAngle` and `maxAngle`\n    if (randomSpacing) {\n      angle = randomFloat(minAngle, maxAngle);\n      angles.push(angle);\n    } //If `randomSpacing` is `false`, space each particle evenly,\n    //starting with the `minAngle` and ending with the `maxAngle`\n    else {\n        if (angle === undefined) angle = minAngle;\n        angles.push(angle);\n        angle += spacing;\n      }\n  } //Make a particle for each angle\n\n\n  angles.forEach(function (angle) {\n    return makeParticle(angle);\n  }); //Make the particle\n\n  function makeParticle(angle) {\n    //Create the particle using the supplied sprite function\n    var particle = spriteFunction(); //Display a random frame if the particle has more than 1 frame\n\n    if (particle.frames.length > 0) {\n      particle.gotoAndStop(randomInt(0, particle.frames.length - 1));\n    } //Set the x and y position\n\n\n    particle.x = x - particle.halfWidth;\n    particle.y = y - particle.halfHeight; //Set a random width and height\n\n    var size = randomInt(minSize, maxSize);\n    particle.width = size;\n    particle.height = size; //Set a random speed to change the scale, alpha and rotation\n\n    particle.scaleSpeed = randomFloat(minScaleSpeed, maxScaleSpeed);\n    particle.alphaSpeed = randomFloat(minAlphaSpeed, maxAlphaSpeed);\n    particle.rotationSpeed = randomFloat(minRotationSpeed, maxRotationSpeed); //Set a random velocity at which the particle should move\n\n    var speed = randomFloat(minSpeed, maxSpeed);\n    particle.vx = speed * Math.cos(angle);\n    particle.vy = speed * Math.sin(angle); //The particle's `update` method is called on each frame of the\n    //game loop\n\n    particle.update = function () {\n      //Add gravity\n      particle.vy += gravity; //Move the particle\n\n      particle.x += particle.vx;\n      particle.y += particle.vy; //Change the particle's `scale`\n\n      if (particle.scaleX - particle.scaleSpeed > 0) {\n        particle.scaleX -= particle.scaleSpeed;\n      }\n\n      if (particle.scaleY - particle.scaleSpeed > 0) {\n        particle.scaleY -= particle.scaleSpeed;\n      } //Change the particle's rotation\n\n\n      particle.rotation += particle.rotationSpeed; //Change the particle's `alpha`\n\n      particle.alpha -= particle.alphaSpeed; //Remove the particle if its `alpha` reaches zero\n\n      if (particle.alpha <= 0) {\n        _remove(particle);\n\n        particles.splice(particles.indexOf(particle), 1);\n      }\n    }; //Push the particle into the `particles` array\n    //The `particles` array needs to be updated by the game loop each\n    //frame\n\n\n    particles.push(particle);\n  }\n}\n/*\r\ntilingSprite\r\n------------\r\n*/\n//export function tilingSprite(spriteFunction, tileHeight, tileWidth, totalWidth, totalHeight) {\n\nfunction tilingSprite(width, height, source) {\n  var x = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  var y = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n  //Figure out the tile's width and height\n  var tileWidth, tileHeight; //If the source is a texture atlas frame, use its\n  //`frame.w` and `frame.h` properties\n\n  if (source.frame) {\n    tileWidth = source.frame.w;\n    tileHeight = source.frame.h;\n  } //If it's an image, use the image's \n  //`width` and `height` properties\n  else {\n      tileWidth = source.width;\n      tileHeight = source.height;\n    } //Figure out the rows and columns.\n  //The number of rows and columns should always be\n  //one greater than the total number of tiles\n  //that can fit in the rectangle. This give us one \n  //additional row and column that we can reposition\n  //to create the infinite scroll effect\n\n\n  var columns, rows; //1. Columns\n  //If the width of the rectangle is greater than the width of the tile,\n  //calculate the number of tile columns\n\n  if (width >= tileWidth) {\n    columns = Math.round(width / tileWidth) + 1;\n  } //If the rectangle's width is less than the width of the\n  //tile, set the columns to 2, which is the minimum\n  else {\n      columns = 2;\n    } //2. Rows\n  //Calculate the tile rows in the same way\n\n\n  if (height >= tileHeight) {\n    rows = Math.round(height / tileHeight) + 1;\n  } else {\n    rows = 2;\n  } //Create a grid of sprites that's just one sprite larger\n  //than the `totalWidth` and `totalHeight`\n\n\n  var tileGrid = grid(columns, rows, tileWidth, tileHeight, false, 0, 0, function () {\n    //Make a sprite from the supplied `source`\n    var tile = sprite(source);\n    return tile;\n  }); //Declare the grid's private properties that we'll use to\n  //help scroll the tiling background\n\n  tileGrid._tileX = 0;\n  tileGrid._tileY = 0; //Create an empty rectangle sprite without a fill or stoke color.\n  //Set it to the supplied `width` and `height`\n\n  var container = rectangle(width, height, \"none\", \"none\");\n  container.x = x;\n  container.y = y; //Set the rectangle's `mask` property to `true`. This switches on `ctx.clip()`\n  //In the rectangle sprite's `render` method.\n\n  container.mask = true; //Add the tile grid to the rectangle container\n\n  container.addChild(tileGrid); //Define the `tileX` and `tileY` properties on the parent container\n  //so that you can scroll the tiling background\n\n  Object.defineProperties(container, {\n    tileX: {\n      get: function get() {\n        return tileGrid._tileX;\n      },\n      set: function set(value) {\n        //Loop through all of the grid's child sprites\n        tileGrid.children.forEach(function (child) {\n          //Figure out the difference between the new position\n          //and the previous position\n          var difference = value - tileGrid._tileX; //Offset the child sprite by the difference\n\n          child.x += difference; //If the x position of the sprite exceeds the total width\n          //of the visible columns, reposition it to just in front of the \n          //left edge of the container. This creates the wrapping\n          //effect\n\n          if (child.x > (columns - 1) * tileWidth) {\n            child.x = 0 - tileWidth + difference;\n          } //Use the same procedure to wrap sprites that \n          //exceed the left boundary\n\n\n          if (child.x < 0 - tileWidth - difference) {\n            child.x = (columns - 1) * tileWidth;\n          }\n        }); //Set the private `_tileX` property to the new value\n\n        tileGrid._tileX = value;\n      },\n      enumerable: true,\n      configurable: true\n    },\n    tileY: {\n      get: function get() {\n        return tileGrid._tileY;\n      },\n      //Follow the same format to wrap sprites on the y axis\n      set: function set(value) {\n        tileGrid.children.forEach(function (child) {\n          var difference = value - tileGrid._tileY;\n          child.y += difference;\n          if (child.y > (rows - 1) * tileHeight) child.y = 0 - tileHeight + difference;\n          if (child.y < 0 - tileHeight - difference) child.y = (rows - 1) * tileHeight;\n        });\n        tileGrid._tileY = value;\n      },\n      enumerable: true,\n      configurable: true\n    }\n  }); //Return the rectangle container\n\n  return container;\n}\n/*\r\nshakingSprites\r\n--------------\r\n\r\nAn array to store all the shaking sprites in the game\r\n*/\n\nvar shakingSprites = [];\n/*\r\nshake\r\n-----\r\n\r\nUsed to create a shaking effect, like a screen shake\r\n*/\n\nfunction shake(sprite) {\n  var magnitude = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 16;\n  var angular = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  //A counter to count the number of shakes\n  var counter = 1; //The total number of shakes (there will be 1 shake per frame)\n\n  var numberOfShakes = 10; //Capture the sprite's position and angle so you can\n  //restore them after the shaking has finished\n\n  var startX = sprite.x,\n      startY = sprite.y,\n      startAngle = sprite.rotation; //Divide the magnitude into 10 units so that you can \n  //reduce the amount of shake by 10 percent each frame\n\n  var magnitudeUnit = magnitude / numberOfShakes; //The `randomInt` helper function\n\n  var randomInt = function randomInt(min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n  }; //Add the sprite to the `shakingSprites` array if it\n  //isn't already there\n\n\n  if (shakingSprites.indexOf(sprite) === -1) {\n    //console.log(\"added\")\n    shakingSprites.push(sprite); //Add an `updateShake` method to the sprite.\n    //The `updateShake` method will be called each frame\n    //in the game loop. The shake effect type can be either\n    //up and down (x/y shaking) or angular (rotational shaking).\n\n    sprite.updateShake = function () {\n      if (angular) {\n        angularShake();\n      } else {\n        upAndDownShake();\n      }\n    };\n  } //The `upAndDownShake` function\n\n\n  function upAndDownShake() {\n    //Shake the sprite while the `counter` is less than \n    //the `numberOfShakes`\n    if (counter < numberOfShakes) {\n      //Reset the sprite's position at the start of each shake\n      sprite.x = startX;\n      sprite.y = startY; //Reduce the magnitude\n\n      magnitude -= magnitudeUnit; //Randomly change the sprite's position\n\n      sprite.x += randomInt(-magnitude, magnitude);\n      sprite.y += randomInt(-magnitude, magnitude); //Add 1 to the counter\n\n      counter += 1;\n    } //When the shaking is finished, restore the sprite to its original \n    //position and remove it from the `shakingSprites` array\n\n\n    if (counter >= numberOfShakes) {\n      sprite.x = startX;\n      sprite.y = startY;\n      shakingSprites.splice(shakingSprites.indexOf(sprite), 1);\n    }\n  } //The `angularShake` function\n  //First set the initial tilt angle to the right (+1) \n\n\n  var tiltAngle = 1;\n\n  function angularShake() {\n    if (counter < numberOfShakes) {\n      //Reset the sprite's rotation\n      sprite.rotation = startAngle; //Reduce the magnitude\n\n      magnitude -= magnitudeUnit; //Rotate the sprite left or right, depending on the direction,\n      //by an amount in radians that matches the magnitude\n\n      sprite.rotation = magnitude * tiltAngle;\n      counter += 1; //Reverse the tilt angle so that the sprite is tilted\n      //in the opposite direction for the next shake\n\n      tiltAngle *= -1;\n    } //When the shaking is finished, reset the sprite's angle and\n    //remove it from the `shakingSprites` array\n\n\n    if (counter >= numberOfShakes) {\n      sprite.rotation = startAngle;\n      shakingSprites.splice(shakingSprites.indexOf(sprite), 1); //console.log(\"removed\")\n    }\n  }\n}\n/*\r\n### progressBar\r\nUse the `progressBar` to display the percentage of assetes being loaded.\r\nTo use it, first make sure you define a `load` state when you intialize the game engine.\r\nHere's an example of a game engine instance that's intialized with 5 assets. The last\r\nargument, `load`, tells the engine that it should apply the `load` state as soon as\r\nthe engine starts.\r\n\r\n    var g = game(\r\n      512, 512, setup,\r\n      [\r\n        \"images/blixyiiUI.png\",\r\n        \"images/blixyiiTileset.png\",\r\n        \"fonts/puzzler.otf\",\r\n        \"sounds/music.wav\",\r\n        \"sounds/bounce.wav\"\r\n      ],\r\n      load\r\n    );\r\n    g.start();\r\n\r\nNext, create a `load` function. It will run in a loop while the assets are loading\r\nand before the `setup` state is run. Here's how to create and update the progress\r\nbar in the load state\r\n\r\n    function load() {\r\n      g.progressBar.create(g.canvas, g.assets);\r\n      g.progressBar.update();\r\n    }\r\n\r\nWhen the assets have finished loading the `setup` state will automatically be run.\r\nRemove the progress bar in the `setup` function state like this:\r\n\r\n    function setup() {\r\n      g.progressBar.remove();\r\n      //...\r\n    }\r\n\r\nThis is just a basic example of a progress bar to help you get started. You can use the\r\nsame format to create your own custom preloading animation.\r\n*/\n\nvar progressBar = {\n  maxWidth: 0,\n  height: 0,\n  backgroundColor: \"gray\",\n  foregroundColor: \"cyan\",\n  backBar: null,\n  frontBar: null,\n  percentage: null,\n  assets: null,\n  initialized: false,\n  //Use the `create` method to create the progress bar\n  create: function create(canvas, assets) {\n    if (!this.initialized) {\n      //Store a reference to the `assets` object\n      this.assets = assets; //Set the maximum width to half the width of the canvas\n\n      this.maxWidth = canvas.width / 2; //Build the progress bar using two rectangle sprites and\n      //one text sprite\n      //1. Create the background bar's gray background\n\n      this.backBar = rectangle(this.maxWidth, 32, this.backgroundColor);\n      this.backBar.x = canvas.width / 2 - this.maxWidth / 2;\n      this.backBar.y = canvas.height / 2 - 16; //2. Create the blue foreground bar. This is the element of the\n      //progress bar that will increase in width as assets load\n\n      this.frontBar = rectangle(this.maxWidth, 32, this.foregroundColor);\n      this.frontBar.x = canvas.width / 2 - this.maxWidth / 2;\n      this.frontBar.y = canvas.height / 2 - 16; //3. A text sprite that will display the percentage\n      //of assets that have loaded\n\n      this.percentage = text(\"0%\", \"28px sans-serif\", \"black\");\n      this.percentage.x = canvas.width / 2 - this.maxWidth / 2 + 12;\n      this.percentage.y = canvas.height / 2 - 16; //Flag the `progressBar` as having been initialized\n\n      this.initialized = true;\n    }\n  },\n  //Use the `update` method to update the width of the bar and \n  //percentage loaded each frame\n  update: function update() {\n    //Change the width of the blue `frontBar` to match the\n    //ratio of assets that have loaded. Adding `+1` to\n    //`assets.loaded` means that the loading bar will appear at 100%\n    //when the last asset is being loaded, which is reassuring for the\n    //player observing the load progress\n    var ratio = (this.assets.loaded + 1) / this.assets.toLoad;\n    this.frontBar.width = this.maxWidth * ratio; //Display the percentage\n\n    this.percentage.content = \"\".concat(Math.floor(ratio * 100), \" %\");\n  },\n  //Use the `remove` method to remove the progress bar when all the\n  //game assets have finished loading\n  remove: function remove() {\n    //Remove the progress bar using the universal sprite `remove`\n    //function\n    _remove(this.frontBar);\n\n    _remove(this.backBar);\n\n    _remove(this.percentage);\n  }\n};\n\n//# sourceURL=webpack:///./src/js/library/display.js?");

/***/ }),

/***/ "./src/js/library/interactive.js":
/*!***************************************!*\
  !*** ./src/js/library/interactive.js ***!
  \***************************************/
/*! exports provided: makePointer, keyboard */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"makePointer\", function() { return makePointer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"keyboard\", function() { return keyboard; });\n/* \r\ninteractive.js\r\n==============\r\n\r\nThis JavaScript file contains objects useful for\r\nadding interactivity to sprites. See the display.js file for\r\nsprite classes that can use this code\r\n\r\n*/\n\n/*\r\nmakePointer\r\n-----------\r\nMakes a pointer object that unifies touch and mouse interactivity.\r\nThe pointer has `x` and `y` properties and `isUp`, `isDown` and\r\n`tapped` Boolean states.\r\n*/\nfunction makePointer(element) {\n  var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var pointer = {\n    element: element,\n    scale: scale,\n    //Private x and y properties\n    _x: 0,\n    _y: 0,\n\n    //The public x and y properties are divided by the scale. If the\n    //HTML element that the pointer is sensitive to (like the canvas)\n    //is scaled up or down, you can change the `scale` value to\n    //correct the pointer's position values\n    get x() {\n      return this._x / this.scale;\n    },\n\n    get y() {\n      return this._y / this.scale;\n    },\n\n    //Add `centerX` and `centerY` getters so that we\n    //can use the pointer's coordinates with easing\n    //and collision functions\n    get centerX() {\n      return this.x;\n    },\n\n    get centerY() {\n      return this.y;\n    },\n\n    //`position` returns an object with x and y properties that\n    //contain the pointer's position\n    get position() {\n      return {\n        x: this.x,\n        y: this.y\n      };\n    },\n\n    //Booleans to track the pointer state\n    isDown: false,\n    isUp: true,\n    tapped: false,\n    //Properties to help measure the time between up and down states\n    downTime: 0,\n    elapsedTime: 0,\n    //Optional `press`,`release` and `tap` methods\n    press: undefined,\n    release: undefined,\n    tap: undefined,\n    //A `dragSprite` property to help with drag and drop\n    dragSprite: null,\n    //The drag offsets to help drag sprites\n    dragOffsetX: 0,\n    dragOffsetY: 0,\n    //The pointer's mouse `moveHandler`\n    moveHandler: function moveHandler(event) {\n      //Get the element that's firing the event\n      var element = event.target; //Find the pointer’s x and y position (for mouse).\n      //Subtract the element's top and left offset from the browser window\n\n      this._x = event.pageX - element.offsetLeft;\n      this._y = event.pageY - element.offsetTop; //Prevent the event's default behavior \n    },\n    //The pointer's `touchmoveHandler`\n    touchmoveHandler: function touchmoveHandler(event) {\n      var element = event.target; //Find the touch point's x and y position\n\n      this._x = event.targetTouches[0].pageX - element.offsetLeft;\n      this._y = event.targetTouches[0].pageY - element.offsetTop;\n    },\n    //The pointer's `downHandler`\n    downHandler: function downHandler(event) {\n      //Set the down states\n      this.isDown = true;\n      this.isUp = false;\n      this.tapped = false; //Capture the current time\n\n      this.downTime = Date.now(); //Call the `press` method if it's been assigned\n\n      if (this.press) this.press();\n    },\n    //The pointer's `touchstartHandler`\n    touchstartHandler: function touchstartHandler(event) {\n      var element = event.target; //Find the touch point's x and y position\n\n      this._x = event.targetTouches[0].pageX - element.offsetLeft;\n      this._y = event.targetTouches[0].pageY - element.offsetTop; //Set the down states\n\n      this.isDown = true;\n      this.isUp = false;\n      this.tapped = false; //Capture the current time\n\n      this.downTime = Date.now(); //Call the `press` method if it's been assigned\n\n      if (this.press) this.press();\n    },\n    //The pointer's `upHandler`\n    upHandler: function upHandler(event) {\n      //Figure out how much time the pointer has been down\n      this.elapsedTime = Math.abs(this.downTime - Date.now()); //If it's less than 200 milliseconds, it must be a tap or click\n\n      if (this.elapsedTime <= 200 && this.tapped === false) {\n        this.tapped = true; //Call the `tap` method if it's been assigned\n\n        if (this.tap) this.tap();\n      }\n\n      this.isUp = true;\n      this.isDown = false; //Call the `release` method if it's been assigned\n\n      if (this.release) this.release();\n    },\n    //The pointer's `touchendHandler`\n    touchendHandler: function touchendHandler(event) {\n      //Figure out how much time the pointer has been down\n      this.elapsedTime = Math.abs(this.downTime - Date.now()); //If it's less than 200 milliseconds, it must be a tap or click\n\n      if (this.elapsedTime <= 200 && this.tapped === false) {\n        this.tapped = true; //Call the `tap` method if it's been assigned\n\n        if (this.tap) this.tap();\n      }\n\n      this.isUp = true;\n      this.isDown = false; //Call the `release` method if it's been assigned\n\n      if (this.release) this.release();\n    },\n    //`hitTestSprite` figures out if the pointer is touching a sprite\n    hitTestSprite: function hitTestSprite(sprite) {\n      //The `hit` variable will become `true` if the pointer is\n      //touching the sprite and remain `false` if it isn't\n      var hit = false; //Is the sprite rectangular?\n\n      if (!sprite.circular) {\n        //Get the position of the sprite's edges using global\n        //coordinates\n        var left = sprite.gx,\n            right = sprite.gx + sprite.width,\n            top = sprite.gy,\n            bottom = sprite.gy + sprite.height; //Find out if the pointer is intersecting the rectangle.\n        //`hit` will become `true` if the pointer is inside the\n        //sprite's area\n\n        hit = this.x > left && this.x < right && this.y > top && this.y < bottom;\n      } //Is the sprite circular?\n      else {\n          //Find the distance between the pointer and the\n          //center of the circle\n          var vx = this.x - (sprite.gx + sprite.radius),\n              vy = this.y - (sprite.gy + sprite.radius),\n              distance = Math.sqrt(vx * vx + vy * vy); //The pointer is intersecting the circle if the\n          //distance is less than the circle's radius\n\n          hit = distance < sprite.radius;\n        }\n\n      return hit;\n    },\n    updateDragAndDrop: function updateDragAndDrop(draggableSprites) {\n      var _this = this;\n\n      //Check whether the pointer is pressed down\n      if (this.isDown) {\n        //You need to capture the co-ordinates at which the pointer was\n        //pressed down and find out if it's touching a sprite\n        //Only run this code if the pointer isn't already dragging\n        //sprite\n        if (this.dragSprite === null) {\n          //Loop through the `draggableSprites` in reverse to start searching at the bottom of the stack\n          for (var i = draggableSprites.length - 1; i > -1; i--) {\n            var sprite = draggableSprites[i]; //Check for a collision with the pointer using `hitTestSprite`\n\n            if (this.hitTestSprite(sprite) && sprite.draggable) {\n              //Calculate the difference between the pointer's\n              //position and the sprite's position\n              this.dragOffsetX = this.x - sprite.gx;\n              this.dragOffsetY = this.y - sprite.gy; //Set the sprite as the pointer's `dragSprite` property\n\n              this.dragSprite = sprite; //The next two lines re-order the `sprites` array so that the\n              //selected sprite is displayed above all the others.\n              //First, splice the sprite out of its current position in\n              //its parent's `children` array\n\n              var children = sprite.parent.children;\n              children.splice(children.indexOf(sprite), 1); //Next, push the `dragSprite` to the end of its `children` array so that it's\n              //displayed last, above all the other sprites\n\n              children.push(sprite); //Reorganize the `draggableSpites` array in the same way\n\n              draggableSprites.splice(draggableSprites.indexOf(sprite), 1);\n              draggableSprites.push(sprite); //Break the loop, because we only need to drag the topmost sprite\n\n              break;\n            }\n          }\n        } //If the pointer is down and it has a `dragSprite`, make the sprite follow the pointer's\n        //position, with the calculated offset\n        else {\n            this.dragSprite.x = this.x - this.dragOffsetX;\n            this.dragSprite.y = this.y - this.dragOffsetY;\n          }\n      } //If the pointer is up, drop the `dragSprite` by setting it to `null`\n\n\n      if (this.isUp) {\n        this.dragSprite = null;\n      } //Change the mouse arrow pointer to a hand if it's over a\n      //draggable sprite\n\n\n      draggableSprites.some(function (sprite) {\n        if (_this.hitTestSprite(sprite) && sprite.draggable) {\n          _this.element.style.cursor = \"pointer\";\n          return true;\n        } else {\n          _this.element.style.cursor = \"auto\";\n          return false;\n        }\n      });\n    }\n  }; //Bind the events to the handlers\n  //Mouse events\n\n  element.addEventListener(\"mousemove\", pointer.moveHandler.bind(pointer), false);\n  element.addEventListener(\"mousedown\", pointer.downHandler.bind(pointer), false); //Add the `mouseup` event to the `window` to\n  //catch a mouse button release outside of the canvas area\n\n  window.addEventListener(\"mouseup\", pointer.upHandler.bind(pointer), false); //Touch events\n\n  element.addEventListener(\"touchmove\", pointer.touchmoveHandler.bind(pointer), false);\n  element.addEventListener(\"touchstart\", pointer.touchstartHandler.bind(pointer), false); //Add the `touchend` event to the `window` object to\n  //catch a mouse button release outside of the canvas area\n\n  window.addEventListener(\"touchend\", pointer.touchendHandler.bind(pointer), false); //Disable the default pan and zoom actions on the `canvas`\n\n  element.style.touchAction = \"none\"; //Return the pointer\n\n  return pointer;\n}\n/*\r\nkeyboard\r\n---\r\n\r\nThe `keyboard` function creates `key` objects\r\nthat listen for keyboard events. Create a new key object like\r\nthis:\r\n\r\n    let keyObject = g.keyboard(asciiKeyCodeNumber);\r\n\r\nThen assign `press` and `release` methods like this:\r\n\r\n  keyObject.press = function() {\r\n    //key object pressed\r\n  };\r\n  keyObject.release = function() {\r\n    //key object released\r\n  };\r\n\r\nKeyboard objects also have `isDown` and `isUp` Booleans that you can check.\r\n\r\n*/\n\nfunction keyboard(keyCode) {\n  var key = {};\n  key.code = keyCode;\n  key.isDown = false;\n  key.isUp = true;\n  key.press = undefined;\n  key.release = undefined; //The `downHandler`\n\n  key.downHandler = function (event) {\n    if (event.keyCode === key.code) {\n      if (key.isUp && key.press) key.press();\n      key.isDown = true;\n      key.isUp = false;\n    } //Prevent the event's default behavior\n\n  }; //The `upHandler`\n\n\n  key.upHandler = function (event) {\n    if (event.keyCode === key.code) {\n      if (key.isDown && key.release) key.release();\n      key.isDown = false;\n      key.isUp = true;\n    }\n  }; //Attach event listeners\n\n\n  window.addEventListener(\"keydown\", key.downHandler.bind(key), false);\n  window.addEventListener(\"keyup\", key.upHandler.bind(key), false); //Return the key object\n\n  return key;\n}\n\n//# sourceURL=webpack:///./src/js/library/interactive.js?");

/***/ }),

/***/ "./src/js/library/sound.js":
/*!*********************************!*\
  !*** ./src/js/library/sound.js ***!
  \*********************************/
/*! exports provided: makeSound, soundEffect */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"makeSound\", function() { return makeSound; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"soundEffect\", function() { return soundEffect; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n//Create the audio context\nvar actx = new AudioContext(); //The sound object\n\nvar Sound = /*#__PURE__*/function () {\n  function Sound(source, loadHandler) {\n    _classCallCheck(this, Sound);\n\n    //Assign the `source` and `loadHandler` values to this object \n    this.source = source;\n    this.loadHandler = loadHandler; //Set the default properties\n\n    this.actx = actx;\n    this.volumeNode = this.actx.createGain();\n    this.panNode = this.actx.createStereoPanner();\n    this.convolverNode = this.actx.createConvolver();\n    this.delayNode = this.actx.createDelay();\n    this.feedbackNode = this.actx.createGain();\n    this.filterNode = this.actx.createBiquadFilter(); //this.panNode.panningModel = \"equalpower\";\n\n    this.soundNode = null;\n    this.buffer = null;\n    this.loop = false;\n    this.playing = false; //Values for the pan and volume getters/setters\n\n    this.panValue = 0;\n    this.volumeValue = 1; //Values to help track and set the start and pause times\n\n    this.startTime = 0;\n    this.startOffset = 0; //The playback rate\n\n    this.playbackRate = 1;\n    this.randomPitch = true; //Reverb parameters\n\n    this.reverb = false;\n    this.reverbImpulse = null; //Echo parameters\n\n    this.echo = false;\n    this.delayValue = 0.3;\n    this.feebackValue = 0.3;\n    this.filterValue = 0; //Load the sound\n\n    this.load();\n  } //The sound object's methods\n\n\n  _createClass(Sound, [{\n    key: \"load\",\n    value: function load() {\n      var _this = this;\n\n      //Use xhr to load the sound file\n      var xhr = new XMLHttpRequest();\n      xhr.open(\"GET\", this.source, true);\n      xhr.responseType = \"arraybuffer\";\n      xhr.addEventListener(\"load\", function () {\n        //Decode the sound and store a reference to the buffer \n        _this.actx.decodeAudioData(xhr.response, function (buffer) {\n          _this.buffer = buffer;\n          _this.hasLoaded = true; //This next bit is optional, but important.\n          //If you have a load manager in your game, call it here so that\n          //the sound is registered as having loaded. \n\n          if (_this.loadHandler) {\n            _this.loadHandler();\n          }\n        }, //Throw an error if the sound can't be decoded\n        function (error) {\n          throw new Error(\"Audio could not be decoded: \" + error);\n        });\n      }); //Send the request to load the file\n\n      xhr.send();\n    }\n  }, {\n    key: \"play\",\n    value: function play() {\n      //Set the time to start the sound (immediately)\n      this.startTime = this.actx.currentTime; //Create a sound node \n\n      this.soundNode = this.actx.createBufferSource(); //Set the sound node's buffer property to the loaded sound\n\n      this.soundNode.buffer = this.buffer; //Connect all the nodes\n\n      this.soundNode.connect(this.volumeNode); //If there's no reverb, bypass the convolverNode\n\n      if (this.reverb === false) {\n        this.volumeNode.connect(this.panNode);\n      } //If there is reverb, connect the `convolverNode` and apply\n      //the impulse response\n      else {\n          this.volumeNode.connect(this.convolverNode);\n          this.convolverNode.connect(this.panNode);\n          this.convolverNode.buffer = this.reverbImpulse;\n        }\n\n      this.panNode.connect(this.actx.destination); //To create the echo effect, connect the volume to the \n      //delay, the delay to the feedback, and the feedback to the\n      //destination\n\n      if (this.echo) {\n        this.feedbackNode.gain.value = this.feebackValue;\n        this.delayNode.delayTime.value = this.delayValue;\n        this.filterNode.frequency.value = this.filterValue;\n        this.delayNode.connect(this.feedbackNode);\n\n        if (this.filterValue > 0) {\n          this.feedbackNode.connect(this.filterNode);\n          this.filterNode.connect(this.delayNode);\n        } else {\n          this.feedbackNode.connect(this.delayNode);\n        }\n\n        this.volumeNode.connect(this.delayNode);\n        this.delayNode.connect(this.panNode);\n      } //Will the sound loop? This can be `true` or `false`\n\n\n      this.soundNode.loop = this.loop; //Set the playback rate\n\n      this.soundNode.playbackRate.value = this.playbackRate; //Finally, use the `start` method to play the sound.\n      //The start time will either be `currentTime`,\n      //or a later time if the sound was paused\n\n      this.soundNode.start(this.startTime, this.startOffset % this.buffer.duration); //Set `playing` to `true` to help control the \n      //`pause` and `restart` methods\n\n      this.playing = true;\n    }\n  }, {\n    key: \"setReverb\",\n    value: function setReverb() {\n      var duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 2;\n      var decay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n      var reverse = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      this.reverbImpulse = impulseResponse(duration, decay, reverse);\n      this.reverb = true;\n    }\n  }, {\n    key: \"setEcho\",\n    value: function setEcho() {\n      var delayValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0.3;\n      var feedbackValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.3;\n      var filterValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      this.delayValue = delayValue;\n      this.feebackValue = feedbackValue;\n      this.filterValue = filterValue;\n      this.echo = true;\n    }\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      //Pause the sound if it's playing, and calculate the\n      //`startOffset` to save the current position \n      if (this.playing) {\n        this.soundNode.stop(this.actx.currentTime);\n        this.startOffset += this.actx.currentTime - this.startTime;\n        this.playing = false;\n        console.log(this.startOffset);\n      }\n    }\n  }, {\n    key: \"restart\",\n    value: function restart() {\n      //Stop the sound if it's playing, reset the start and offset times,\n      //then call the `play` method again\n      if (this.playing) {\n        this.soundNode.stop(this.actx.currentTime);\n      }\n\n      this.startOffset = 0;\n      this.startPoint = 0;\n      this.endPoint = this.buffer.duration;\n      this.play();\n    }\n  }, {\n    key: \"playFrom\",\n    value: function playFrom(value) {\n      if (this.playing) {\n        this.soundNode.stop(this.actx.currentTime);\n      }\n\n      this.startOffset = value;\n      this.play();\n    } //An experimental `playSection` method used to play a section of a\n    //sound\n\n  }, {\n    key: \"playSection\",\n    value: function playSection(start, end) {\n      if (this.playing) {\n        this.soundNode.stop(this.actx.currentTime);\n      }\n\n      if (this.startOffset === 0) this.startOffset = start; //Set the time to start the sound (immediately)\n\n      this.startTime = this.actx.currentTime; //Create a sound node \n\n      this.soundNode = this.actx.createBufferSource(); //Set the sound node's buffer property to the loaded sound\n\n      this.soundNode.buffer = this.buffer; //Connect the sound to the pan, connect the pan to the\n      //volume, and connect the volume to the destination\n\n      this.soundNode.connect(this.panNode);\n      this.panNode.connect(this.volumeNode);\n      this.volumeNode.connect(this.actx.destination); //Will the sound loop? This can be `true` or `false`\n\n      this.soundNode.loop = this.loop;\n      this.soundNode.loopStart = start;\n      this.soundNode.loopEnd = end; //Find out what the duration of the sound is\n\n      var duration = end - start; //Finally, use the `start` method to play the sound.\n      //The start time will either be `currentTime`,\n      //or a later time if the sound was paused\n\n      this.soundNode.start(this.startTime, this.startOffset % this.buffer.duration, duration); //Set `playing` to `true` to help control the \n      //`pause` and `restart` methods\n\n      this.playing = true;\n    } //Volume and pan getters/setters\n\n  }, {\n    key: \"volume\",\n    get: function get() {\n      return this.volumeValue;\n    },\n    set: function set(value) {\n      this.volumeNode.gain.value = value;\n      this.volumeValue = value;\n    }\n  }, {\n    key: \"pan\",\n    get: function get() {\n      return this.panNode.pan.value;\n    },\n    set: function set(value) {\n      this.panNode.pan.value = value;\n    }\n  }]);\n\n  return Sound;\n}(); //Create a high-level wrapper to keep our API consistent and flexible\n\n\nfunction makeSound(source, loadHandler) {\n  return new Sound(source, loadHandler);\n}\n/*\r\nsoundEffect\r\n-----------\r\n\r\nThe `soundEffect` function lets you generate your sounds and musical notes from scratch\r\n(Reverb effect requires the `impulseResponse` function that you'll see further ahead in this file)\r\nHere's a model the illustrates how to use it, along with a description\r\nof the parameters\r\n\r\n    soundEffect(\r\n      frequencyValue,  //The sound's fequency pitch in Hertz\r\n      attack,          //The time, in seconds, to fade the sound in\r\n      decay,           //The time, in seconds, to fade the sound out\r\n      type,            //waveform type: \"sine\", \"triangle\", \"square\", \"sawtooth\"\r\n      volumeValue,     //The sound's maximum volume\r\n      panValue,        //The speaker pan. left: -1, middle: 0, right: 1\r\n      wait,            //The time, in seconds, to wait before playing the sound\r\n      pitchBendAmount, //The number of Hz in which to bend the sound's pitch down\r\n      reverse,         //If `reverse` is true the pitch will bend up\r\n      randomValue,     //A range, in Hz, within which to randomize the pitch\r\n      dissonance,      //A value in Hz. Creates 2 additional dissonant frequencies \r\n      echo,            //An array: [delayTime, feedbackTime, filterValue]\r\n      reverb           //An array: [duration, decayRate, reverse?]\r\n    );\r\n\r\nTo create a custom sound effect, define all the parameters that characterize your sound. Here's how to\r\ncreate a laser shooting sound:\r\n\r\n    soundEffect(\r\n      1046.5,           //frequency\r\n      0,                //attack\r\n      0.3,              //decay\r\n      \"sawtooth\",       //waveform\r\n      1,                //Volume\r\n      -0.8,             //pan\r\n      0,                //wait before playing\r\n      1200,             //pitch bend amount\r\n      false,            //reverse bend\r\n      0,                //random pitch range\r\n      25,               //dissonance\r\n      [0.2, 0.2, 2000], //echo: [delay, feedback, filter]\r\n      undefined         //reverb: [duration, decay, reverse?]\r\n    );\r\n\r\nExperiment by changing these parameters to see what kinds of effects you can create, and build\r\nyour own library of custom sound effects for games.\r\n*/\n\nfunction soundEffect(frequencyValue) {\n  var attack = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var decay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  var type = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"sine\";\n  var volumeValue = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;\n  var panValue = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n  var wait = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\n  var pitchBendAmount = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;\n  var reverse = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : false;\n  var randomValue = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : 0;\n  var dissonance = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : 0;\n  var echo = arguments.length > 11 && arguments[11] !== undefined ? arguments[11] : undefined;\n  var reverb = arguments.length > 12 && arguments[12] !== undefined ? arguments[12] : undefined;\n  //Create oscillator, gain and pan nodes, and connect them\n  //together to the destination\n  var oscillator = actx.createOscillator(),\n      volume = actx.createGain(),\n      pan = actx.createStereoPanner();\n  oscillator.connect(volume);\n  volume.connect(pan);\n  pan.connect(actx.destination); //Set the supplied values\n\n  volume.gain.value = volumeValue;\n  pan.pan.value = panValue;\n  oscillator.type = type; //Optionally randomize the pitch. If the `randomValue` is greater\n  //than zero, a random pitch is selected that's within the range\n  //specified by `frequencyValue`. The random pitch will be either\n  //above or below the target frequency.\n\n  var frequency;\n\n  var randomInt = function randomInt(min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n  };\n\n  if (randomValue > 0) {\n    frequency = randomInt(frequencyValue - randomValue / 2, frequencyValue + randomValue / 2);\n  } else {\n    frequency = frequencyValue;\n  }\n\n  oscillator.frequency.value = frequency; //Apply effects\n\n  if (attack > 0) fadeIn(volume);\n  if (decay > 0) fadeOut(volume);\n  if (pitchBendAmount > 0) pitchBend(oscillator);\n  if (echo) addEcho(volume);\n  if (reverb) addReverb(volume);\n  if (dissonance > 0) addDissonance(); //Play the sound\n\n  play(oscillator); //The helper functions:\n  //Reverb\n\n  function addReverb(volumeNode) {\n    var convolver = actx.createConvolver();\n    convolver.buffer = impulseResponse(reverb[0], reverb[1], reverb[2]);\n    volumeNode.connect(convolver);\n    convolver.connect(pan);\n  } //Echo\n\n\n  function addEcho(volumeNode) {\n    //Create the nodes\n    var feedback = actx.createGain(),\n        delay = actx.createDelay(),\n        filter = actx.createBiquadFilter(); //Set their values (delay time, feedback time and filter frequency)\n\n    delay.delayTime.value = echo[0];\n    feedback.gain.value = echo[1];\n    if (echo[2]) filter.frequency.value = echo[2]; //Create the delay feedback loop, with\n    //optional filtering\n\n    delay.connect(feedback);\n\n    if (echo[2]) {\n      feedback.connect(filter);\n      filter.connect(delay);\n    } else {\n      feedback.connect(delay);\n    } //Connect the delay loop to the oscillator's volume\n    //node, and then to the destination\n\n\n    volumeNode.connect(delay); //Connect the delay loop to the main sound chain's\n    //pan node, so that the echo effect is directed to\n    //the correct speaker\n\n    delay.connect(pan);\n  } //Fade in (the sound’s “attack”)\n\n\n  function fadeIn(volumeNode) {\n    //Set the volume to 0 so that you can fade in from silence\n    volumeNode.gain.value = 0;\n    volumeNode.gain.linearRampToValueAtTime(0, actx.currentTime + wait);\n    volumeNode.gain.linearRampToValueAtTime(volumeValue, actx.currentTime + wait + attack);\n  } //Fade out (the sound’s “decay”)\n\n\n  function fadeOut(volumeNode) {\n    volumeNode.gain.linearRampToValueAtTime(volumeValue, actx.currentTime + attack + wait);\n    volumeNode.gain.linearRampToValueAtTime(0, actx.currentTime + wait + attack + decay);\n  } //Pitch bend.\n  //Uses `linearRampToValueAtTime` to bend the sound’s frequency up or down\n\n\n  function pitchBend(oscillatorNode) {\n    //Get the frequency of the current oscillator\n    var frequency = oscillatorNode.frequency.value; //If `reverse` is true, make the sound drop in pitch.\n    //(Useful for shooting sounds)\n\n    if (!reverse) {\n      oscillatorNode.frequency.linearRampToValueAtTime(frequency, actx.currentTime + wait);\n      oscillatorNode.frequency.linearRampToValueAtTime(frequency - pitchBendAmount, actx.currentTime + wait + attack + decay);\n    } //If `reverse` is false, make the note rise in pitch. \n    //(Useful for jumping sounds)\n    else {\n        oscillatorNode.frequency.linearRampToValueAtTime(frequency, actx.currentTime + wait);\n        oscillatorNode.frequency.linearRampToValueAtTime(frequency + pitchBendAmount, actx.currentTime + wait + attack + decay);\n      }\n  } //Dissonance\n\n\n  function addDissonance() {\n    //Create two more oscillators and gain nodes\n    var d1 = actx.createOscillator(),\n        d2 = actx.createOscillator(),\n        d1Volume = actx.createGain(),\n        d2Volume = actx.createGain(); //Set the volume to the `volumeValue`\n\n    d1Volume.gain.value = volumeValue;\n    d2Volume.gain.value = volumeValue; //Connect the oscillators to the gain and destination nodes\n\n    d1.connect(d1Volume);\n    d1Volume.connect(actx.destination);\n    d2.connect(d2Volume);\n    d2Volume.connect(actx.destination); //Set the waveform to \"sawtooth\" for a harsh effect\n\n    d1.type = \"sawtooth\";\n    d2.type = \"sawtooth\"; //Make the two oscillators play at frequencies above and\n    //below the main sound's frequency. Use whatever value was\n    //supplied by the `dissonance` argument\n\n    d1.frequency.value = frequency + dissonance;\n    d2.frequency.value = frequency - dissonance; //Apply effects to the gain and oscillator\n    //nodes to match the effects on the main sound\n\n    if (attack > 0) {\n      fadeIn(d1Volume);\n      fadeIn(d2Volume);\n    }\n\n    if (decay > 0) {\n      fadeOut(d1Volume);\n      fadeOut(d2Volume);\n    }\n\n    if (pitchBendAmount > 0) {\n      pitchBend(d1);\n      pitchBend(d2);\n    }\n\n    if (echo) {\n      addEcho(d1Volume);\n      addEcho(d2Volume);\n    }\n\n    if (reverb) {\n      addReverb(d1Volume);\n      addReverb(d2Volume);\n    } //Play the sounds\n\n\n    play(d1);\n    play(d2);\n  } //The `play` function that starts the oscillators\n\n\n  function play(oscillatorNode) {\n    oscillatorNode.start(actx.currentTime + wait);\n  }\n} //`impulseResponse` is a function that uses a convolver node to create\n//a dynamic reverb effect\n//based on \"Simple-Reverb\": github.com/web-audio-components/simple-reverb\n\nfunction impulseResponse() {\n  var duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 2;\n  var decay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n  var reverse = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  //The length of the reverb effect will be the audio context's\n  //`sampleRate` (the sound resolution) multiplied by the supplied duration\n  var length = actx.sampleRate * duration; //Create an audio buffer (an empty sound container) to store the \n  //reverb effect. The audio context's `createBuffer` method lets you\n  //do this. It creates a space in memory to store all the sound data in \n  //\"sample frame\" units. It takes three arguments: \n  //1. numberOfChannels: 2, for right and left speakers (maximum is 32) \n  //bufferSize: the size of the buffer in sample frames \n  //sampleRate: the resolution of the sound\n\n  var impulse = actx.createBuffer(2, length, actx.sampleRate); //Use `getChannelData` to initialize empty arrays to store sound data for\n  //the left and right channels. The left channel is `0`, the right\n  //channel is `1`\n\n  var left = impulse.getChannelData(0),\n      right = impulse.getChannelData(1); //Fill each channel data array element with random white noise that decays\n  //logarithmically (a natural sounding proportionate way). \n  //This noise will be used by the convolver node to\n  //create the reverb effect\n  //Loop through each sample-frame and fill the channel\n  //data with random noise\n\n  for (var i = 0; i < length; i++) {\n    //Apply the reverse effect, if `reverse` is `true`\n    var n = void 0;\n\n    if (reverse) {\n      n = length - i;\n    } else {\n      n = i;\n    } //Fill the left and right channels with random white noise which\n    //decays exponentially\n\n\n    left[i] = (Math.random() * 2 - 1) * Math.pow(1 - n / length, decay);\n    right[i] = (Math.random() * 2 - 1) * Math.pow(1 - n / length, decay);\n  }\n\n  return impulse;\n}\n\n//# sourceURL=webpack:///./src/js/library/sound.js?");

/***/ }),

/***/ "./src/js/library/tween.js":
/*!*********************************!*\
  !*** ./src/js/library/tween.js ***!
  \*********************************/
/*! exports provided: tweens, tweenProperty, fadeOut, fadeIn, pulse, slide, breathe, scale, strobe, wobble, removeTween, followCurve, walkPath, walkCurve */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"tweens\", function() { return tweens; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"tweenProperty\", function() { return tweenProperty; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fadeOut\", function() { return fadeOut; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fadeIn\", function() { return fadeIn; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pulse\", function() { return pulse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"slide\", function() { return slide; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"breathe\", function() { return breathe; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scale\", function() { return scale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"strobe\", function() { return strobe; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"wobble\", function() { return wobble; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"removeTween\", function() { return removeTween; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"followCurve\", function() { return followCurve; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"walkPath\", function() { return walkPath; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"walkCurve\", function() { return walkCurve; });\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/*\r\ntweens\r\n------\r\nAn array to store all the tweens in the game\r\n*/\nvar tweens = []; //Easing functions\n//Linear\n\nvar linear = function linear(x) {\n  return x;\n}; //Smoothstep\n\n\nvar smoothstep = function smoothstep(x) {\n  return x * x * (3 - 2 * x);\n};\n\nvar smoothstepSquared = function smoothstepSquared(x) {\n  return Math.pow(x * x * (3 - 2 * x), 2);\n};\n\nvar smoothstepCubed = function smoothstepCubed(x) {\n  return Math.pow(x * x * (3 - 2 * x), 3);\n}; //Acceleration\n\n\nvar acceleration = function acceleration(x) {\n  return x * x;\n};\n\nvar accelerationCubed = function accelerationCubed(x) {\n  return Math.pow(x * x, 3);\n}; //Deceleration\n\n\nvar deceleration = function deceleration(x) {\n  return 1 - Math.pow(1 - x, 2);\n};\n\nvar decelerationCubed = function decelerationCubed(x) {\n  return 1 - Math.pow(1 - x, 3);\n}; //Sine\n\n\nvar sine = function sine(x) {\n  return Math.sin(x * Math.PI / 2);\n};\n\nvar sineSquared = function sineSquared(x) {\n  return Math.pow(Math.sin(x * Math.PI / 2), 2);\n};\n\nvar sineCubed = function sineCubed(x) {\n  return Math.pow(Math.sin(x * Math.PI / 2), 2);\n};\n\nvar inverseSine = function inverseSine(x) {\n  return 1 - Math.sin((1 - x) * Math.PI / 2);\n};\n\nvar inverseSineSquared = function inverseSineSquared(x) {\n  return 1 - Math.pow(Math.sin((1 - x) * Math.PI / 2), 2);\n};\n\nvar inverseSineCubed = function inverseSineCubed(x) {\n  return 1 - Math.pow(Math.sin((1 - x) * Math.PI / 2), 3);\n}; //`sineComplete` uses the whole sine curve, and the effect is the same as\n//smoothstep, but more computationally expensive.\n\n\nvar sineComplete = function sineComplete(x) {\n  return 0.5 - Math.cos(-x * Math.PI) * 0.5;\n}; //Weighted average\n//Good to use if the destination value is changing dynamically\n//arguments: \n//`p`: sprite property, \n//`d`: destination value, \n//`w`: amount to weight (5 to 50 is a good range of values to start with)\n\n\nvar weightedAverage = function weightedAverage(p, d, w) {\n  return (p * (w - 1) + d) / w;\n}; //Spline\n//An implementation of Catmull-Rom spline\n//arguments:\n//t: ratio\n//p0 to p3: points along the path\n\n\nvar spline = function spline(t, a, b, c, d) {\n  return 0.5 * (2 * b + (-a + c) * t + (2 * a - 5 * b + 4 * c - d) * t * t + (-a + 3 * b - 3 * c + d) * t * t * t);\n}; //Bezier curve\n\n\nfunction cubicBezier(t, a, b, c, d) {\n  var t2 = t * t;\n  var t3 = t2 * t;\n  return a + (-a * 3 + t * (3 * a - a * t)) * t + (3 * b + t * (-6 * b + b * 3 * t)) * t + (c * 3 - c * 3 * t) * t2 + d * t3;\n}\n\nvar ease = {\n  //Linear\n  linear: function linear(x) {\n    return x;\n  },\n  //Smoothstep\n  smoothstep: function smoothstep(x) {\n    return x * x * (3 - 2 * x);\n  },\n  smoothstepSquared: function smoothstepSquared(x) {\n    return Math.pow(x * x * (3 - 2 * x), 2);\n  },\n  smoothstepCubed: function smoothstepCubed(x) {\n    return Math.pow(x * x * (3 - 2 * x), 3);\n  },\n  //Acceleration\n  acceleration: function acceleration(x) {\n    return x * x;\n  },\n  accelerationCubed: function accelerationCubed(x) {\n    return Math.pow(x * x, 3);\n  },\n  //Deceleration\n  deceleration: function deceleration(x) {\n    return 1 - Math.pow(1 - x, 2);\n  },\n  decelerationCubed: function decelerationCubed(x) {\n    return 1 - Math.pow(1 - x, 3);\n  },\n  //Sine\n  sine: function sine(x) {\n    return Math.sin(x * Math.PI / 2);\n  },\n  sineSquared: function sineSquared(x) {\n    return Math.pow(Math.sin(x * Math.PI / 2), 2);\n  },\n  sineCubed: function sineCubed(x) {\n    return Math.pow(Math.sin(x * Math.PI / 2), 2);\n  },\n  inverseSine: function inverseSine(x) {\n    return 1 - Math.sin((1 - x) * Math.PI / 2);\n  },\n  inverseSineSquared: function inverseSineSquared(x) {\n    return 1 - Math.pow(Math.sin((1 - x) * Math.PI / 2), 2);\n  },\n  inverseSineCubed: function inverseSineCubed(x) {\n    return 1 - Math.pow(Math.sin((1 - x) * Math.PI / 2), 3);\n  },\n  //Spline\n  spline: function spline(t, p0, p1, p2, p3) {\n    return 0.5 * (2 * p1 + (-p0 + p2) * t + (2 * p0 - 5 * p1 + 4 * p2 - p3) * t * t + (-p0 + 3 * p1 - 3 * p2 + p3) * t * t * t);\n  }\n};\nfunction tweenProperty(sprite, //Sprite object\nproperty, //String property\nstartValue, //Tween start value\nendValue, //Tween end value\ntotalFrames) //Delay in milliseconds before repeating\n{\n  var type = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [\"smoothstep\"];\n  var yoyo = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n  var delayBeforeRepeat = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;\n  //Create the tween object\n  var o = {}; //If the tween is a spline, set the\n  //start and end magnitude values\n\n  if (type[0] === \"spline\") {\n    o.startMagnitude = type[1];\n    o.endMagnitude = type[2];\n  } //Use `o.start` to make a new tween using the current\n  //end point values\n\n\n  o.start = function (startValue, endValue) {\n    //Clone the start and end values so that any possible references to sprite\n    //properties are converted to ordinary numbers \n    o.startValue = JSON.parse(JSON.stringify(startValue));\n    o.endValue = JSON.parse(JSON.stringify(endValue));\n    o.playing = true;\n    o.totalFrames = totalFrames;\n    o.frameCounter = 0; //Add the tween to the global `tweens` array. The `tweens` array is\n    //updated on each frame\n\n    tweens.push(o);\n  }; //Call `o.start` to start the tween\n\n\n  o.start(startValue, endValue); //The `update` method will be called on each frame by the game loop.\n  //This is what makes the tween move\n\n  o.update = function () {\n    var time, curvedTime;\n\n    if (o.playing) {\n      //If the elapsed frames are less than the total frames,\n      //use the tweening formulas to move the sprite\n      if (o.frameCounter < o.totalFrames) {\n        //Find the normalized value\n        var normalizedTime = o.frameCounter / o.totalFrames; //Select the correct easing function from the \n        //`ease` object’s library of easing functions\n        //If it's not a spline, use one of the ordinary easing functions\n\n        if (type[0] !== \"spline\") {\n          curvedTime = ease[type](normalizedTime);\n        } //If it's a spline, use the `spline` function and apply the\n        //2 additional `type` array values as the spline's start and\n        //end points\n        else {\n            curvedTime = ease.spline(normalizedTime, o.startMagnitude, 0, 1, o.endMagnitude);\n          } //Interpolate the sprite's property based on the curve\n\n\n        sprite[property] = o.endValue * curvedTime + o.startValue * (1 - curvedTime);\n        o.frameCounter += 1;\n      } //When the tween has finished playing, run the end tasks\n      else {\n          o.end();\n        }\n    }\n  }; //The `end` method will be called when the tween is finished\n\n\n  o.end = function () {\n    //Set `playing` to `false`\n    o.playing = false; //Call the tween's `onComplete` method, if it's been assigned\n\n    if (o.onComplete) o.onComplete(); //Remove the tween from the `tweens` array\n\n    tweens.splice(tweens.indexOf(o), 1); //If the tween's `yoyo` property is `true`, create a new tween\n    //using the same values, but use the current tween's `startValue`\n    //as the next tween's `endValue` \n\n    if (yoyo) {\n      wait(delayBeforeRepeat).then(function () {\n        o.start(o.endValue, o.startValue);\n      });\n    }\n  }; //Pause and play methods\n\n\n  o.play = function () {\n    return o.playing = true;\n  };\n\n  o.pause = function () {\n    return o.playing = false;\n  }; //Return the tween object\n\n\n  return o;\n}\n/* High level tween functions */\n//`fadeOut`\n\nfunction fadeOut(sprite) {\n  var frames = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 60;\n  return tweenProperty(sprite, \"alpha\", sprite.alpha, 0, frames, [\"sine\"]);\n} //`fadeIn`\n\nfunction fadeIn(sprite) {\n  var frames = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 60;\n  return tweenProperty(sprite, \"alpha\", sprite.alpha, 1, frames, [\"sine\"]);\n} //`pulse`\n//Fades the sprite in and out at a steady rate.\n//Set the `minAlpha` to something greater than 0 if you\n//don't want the sprite to fade away completely\n\nfunction pulse(sprite) {\n  var frames = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 60;\n  var minAlpha = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  return tweenProperty(sprite, \"alpha\", sprite.alpha, minAlpha, frames, [\"smoothstep\"], true);\n} //`makeTween` is a general function for making complex tweens\n//out of multiple `tweenProperty` functions. It's one argument,\n//`tweensToAdd` is an array containing multiple `tweenProperty` calls\n\nfunction makeTween(tweensToAdd) {\n  //Create an object to manage the tweens\n  var o = {}; //Create a `tweens` array to store the new tweens\n\n  o.tweens = []; //Make a new tween for each array\n\n  tweensToAdd.forEach(function (tweenPropertyArguments) {\n    //Use the tween property arguments to make a new tween\n    var newTween = tweenProperty.apply(void 0, _toConsumableArray(tweenPropertyArguments)); //Push the new tween into this object's internal `tweens` array\n\n    o.tweens.push(newTween);\n  }); //Add a counter to keep track of the\n  //number of tweens that have completed their actions\n\n  var completionCounter = 0; //`o.completed` will be called each time one of the tweens\n  //finishes\n\n  o.completed = function () {\n    //Add 1 to the `completionCounter`\n    completionCounter += 1; //If all tweens have finished, call the user-defined `onComplete`\n    //method, if it's been assigned. Reset the `completionCounter`\n\n    if (completionCounter === o.tweens.length) {\n      if (o.onComplete) o.onComplete();\n      completionCounter = 0;\n    }\n  }; //Add `onComplete` methods to all tweens\n\n\n  o.tweens.forEach(function (tween) {\n    tween.onComplete = function () {\n      return o.completed();\n    };\n  }); //Add pause and play methods to control all the tweens\n\n  o.pause = function () {\n    o.tweens.forEach(function (tween) {\n      tween.playing = false;\n    });\n  };\n\n  o.play = function () {\n    o.tweens.forEach(function (tween) {\n      tween.playing = true;\n    });\n  }; //Return the tween object\n\n\n  return o;\n}\n\nfunction slide(sprite, endX, endY) {\n  var frames = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 60;\n  var type = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [\"smoothstep\"];\n  var yoyo = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  var delayBeforeRepeat = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\n  return makeTween([//Create the x axis tween\n  [sprite, \"x\", sprite.x, endX, frames, type, yoyo, delayBeforeRepeat], //Create the y axis tween\n  [sprite, \"y\", sprite.y, endY, frames, type, yoyo, delayBeforeRepeat]]);\n}\nfunction breathe(sprite, endScaleX, endScaleY) {\n  var frames = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 60;\n  var yoyo = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n  var delayBeforeRepeat = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n  return makeTween([//Create the scaleX tween\n  [sprite, \"scaleX\", sprite.scaleX, endScaleX, frames, [\"smoothstepSquared\"], yoyo, delayBeforeRepeat], //Create the scaleY tween\n  [sprite, \"scaleY\", sprite.scaleY, endScaleY, frames, [\"smoothstepSquared\"], yoyo, delayBeforeRepeat]]);\n}\nfunction scale(sprite, endScaleX, endScaleY) {\n  var frames = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 60;\n  return makeTween([//Create the scaleX tween\n  [sprite, \"scaleX\", sprite.scaleX, endScaleX, frames, [\"smoothstep\"], false], //Create the scaleY tween\n  [sprite, \"scaleY\", sprite.scaleY, endScaleY, frames, [\"smoothstep\"], false]]);\n}\nfunction strobe(sprite) {\n  var scaleFactor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1.3;\n  var startMagnitude = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10;\n  var endMagnitude = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 20;\n  var frames = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 10;\n  var yoyo = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n  var delayBeforeRepeat = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\n  return makeTween([//Create the scaleX tween\n  [sprite, \"scaleX\", sprite.scaleX, scaleFactor, frames, [\"spline\", startMagnitude, endMagnitude], yoyo, delayBeforeRepeat], //Create the scaleY tween\n  [sprite, \"scaleY\", sprite.scaleY, scaleFactor, frames, [\"spline\", startMagnitude, endMagnitude], yoyo, delayBeforeRepeat]]);\n}\nfunction wobble(sprite) {\n  var scaleFactorX = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1.2;\n  var scaleFactorY = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1.2;\n  var frames = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 10;\n  var xStartMagnitude = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 10;\n  var xEndMagnitude = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 10;\n  var yStartMagnitude = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : -10;\n  var yEndMagnitude = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : -10;\n  var friction = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0.98;\n  var yoyo = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : true;\n  var delayBeforeRepeat = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : 0;\n  var o = makeTween([//Create the scaleX tween\n  [sprite, \"scaleX\", sprite.scaleX, scaleFactorX, frames, [\"spline\", xStartMagnitude, xEndMagnitude], yoyo, delayBeforeRepeat], //Create the scaleY tween\n  [sprite, \"scaleY\", sprite.scaleY, scaleFactorY, frames, [\"spline\", yStartMagnitude, yEndMagnitude], yoyo, delayBeforeRepeat]]); //Add some friction to the `endValue` at the end of each tween \n\n  o.tweens.forEach(function (tween) {\n    tween.onComplete = function () {\n      //Add friction if the `endValue` is greater than 1\n      if (tween.endValue > 1) {\n        tween.endValue *= friction; //Set the `endValue` to 1 when the effect is finished and \n        //remove the tween from the global `tweens` array\n\n        if (tween.endValue <= 1) {\n          tween.endValue = 1;\n          removeTween(tween);\n        }\n      }\n    };\n  });\n  return o;\n}\n/*\r\nremoveTween\r\n-----------\r\nA utility to remove tweens from the game\r\n\r\n*/\n\nfunction removeTween(tweenObject) {\n  //Remove the tween if `tweenObject` doesn't have any nested\n  //tween objects\n  if (!tweenObject.tweens) {\n    tweenObject.pause();\n    tweens.splice(tweens.indexOf(tweenObject), 1); //Otherwise, remove the nested tween objects\n  } else {\n    tweenObject.pause();\n    tweenObject.tweens.forEach(function (element) {\n      tweens.splice(tweens.indexOf(element), 1);\n    });\n  }\n}\n/*\r\nfollowCurve\r\n------------\r\n*/\n\nfunction followCurve(sprite, pointsArray, totalFrames) {\n  var type = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [\"smoothstep\"];\n  var yoyo = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  var delayBeforeRepeat = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n  //Create the tween object\n  var o = {};\n\n  if (type[0] === \"spline\") {\n    o.startMagnitude = type[1];\n    o.endMagnitude = type[2];\n  } //Use `tween.start` to make a new tween using the current\n  //end point values\n\n\n  o.start = function (pointsArray) {\n    o.playing = true;\n    o.totalFrames = totalFrames;\n    o.frameCounter = 0; //Clone the points array\n\n    o.pointsArray = JSON.parse(JSON.stringify(pointsArray)); //Add the tween to the global `tweens` array. The global `tweens` array is\n    //updated on each frame\n\n    tweens.push(o);\n  }; //Call `tween.start` to start the first tween\n\n\n  o.start(pointsArray); //The `update` method will be called on each frame by the game loop.\n  //This is what makes the tween move\n\n  o.update = function () {\n    var normalizedTime,\n        curvedTime,\n        p = o.pointsArray;\n\n    if (o.playing) {\n      //If the elapsed frames are less than the total frames,\n      //use the tweening formulas to move the sprite\n      if (o.frameCounter < o.totalFrames) {\n        //Find the normalized value\n        normalizedTime = o.frameCounter / o.totalFrames; //Select the correct easing function\n        //If it's not a spline, use one of the ordinary tween\n        //functions\n\n        if (type[0] !== \"spline\") {\n          curvedTime = ease[type](normalizedTime);\n        } //If it's a spline, use the `spine` function and apply the\n        //2 additional `type` array values as the spline's start and\n        //end points\n        else {\n            //curve = tweenFunction.spline(n, type[1], 0, 1, type[2]);\n            curvedTime = ease.spline(normalizedTime, o.startMagnitude, 0, 1, o.endMagnitude);\n          } //Apply the Bezier curve to the sprite's position \n\n\n        sprite.x = cubicBezier(curvedTime, p[0][0], p[1][0], p[2][0], p[3][0]);\n        sprite.y = cubicBezier(curvedTime, p[0][1], p[1][1], p[2][1], p[3][1]); //Add one to the `elapsedFrames`\n\n        o.frameCounter += 1;\n      } //When the tween has finished playing, run the end tasks\n      else {\n          o.end();\n        }\n    }\n  }; //The `end` method will be called when the tween is finished\n\n\n  o.end = function () {\n    //Set `playing` to `false`\n    o.playing = false; //Call the tween's `onComplete` method, if it's been\n    //assigned\n\n    if (o.onComplete) o.onComplete(); //Remove the tween from the global `tweens` array\n\n    tweens.splice(tweens.indexOf(o), 1); //If the tween's `yoyo` property is `true`, reverse the array and\n    //use it to create a new tween\n\n    if (yoyo) {\n      wait(delayBeforeRepeat).then(function () {\n        o.pointsArray = o.pointsArray.reverse();\n        o.start(o.pointsArray);\n      });\n    }\n  }; //Pause and play methods\n\n\n  o.pause = function () {\n    o.playing = false;\n  };\n\n  o.play = function () {\n    o.playing = true;\n  }; //Return the tween object\n\n\n  return o;\n}\nfunction walkPath(sprite, //The sprite\noriginalPathArray) //Delay, in milliseconds, between sections\n{\n  var totalFrames = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 300;\n  var type = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [\"smoothstep\"];\n  var loop = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  var yoyo = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  var delayBetweenSections = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\n  //Clone the path array so that any possible references to sprite\n  //properties are converted into ordinary numbers \n  var pathArray = JSON.parse(JSON.stringify(originalPathArray)); //Figure out the duration, in frames, of each path section by \n  //dividing the `totalFrames` by the length of the `pathArray`\n\n  var frames = totalFrames / pathArray.length; //Set the current point to 0, which will be the first waypoint\n\n  var currentPoint = 0; //Make the first path using the internal `makePath` function (below)\n\n  var tween = makePath(currentPoint); //The `makePath` function creates a single tween between two points and\n  //then schedules the next path to be made after it\n\n  function makePath(currentPoint) {\n    //Use the `makeTween` function to tween the sprite's\n    //x and y position\n    var tween = makeTween([//Create the x axis tween between the first x value in the\n    //current point and the x value in the following point\n    [sprite, \"x\", pathArray[currentPoint][0], pathArray[currentPoint + 1][0], frames, type], //Create the y axis tween in the same way\n    [sprite, \"y\", pathArray[currentPoint][1], pathArray[currentPoint + 1][1], frames, type]]); //When the tween is complete, advance the `currentPoint` by one.\n    //Add an optional delay between path segments, and then make the\n    //next connecting path\n\n    tween.onComplete = function () {\n      //Advance to the next point\n      currentPoint += 1; //If the sprite hasn't reached the end of the\n      //path, tween the sprite to the next point\n\n      if (currentPoint < pathArray.length - 1) {\n        wait(delayBetweenSections).then(function () {\n          tween = makePath(currentPoint);\n        });\n      } //If we've reached the end of the path, optionally\n      //loop and yoyo it\n      else {\n          //Reverse the path if `loop` is `true`\n          if (loop) {\n            //Reverse the array if `yoyo` is `true`\n            if (yoyo) pathArray.reverse(); //Optionally wait before restarting\n\n            wait(delayBetweenSections).then(function () {\n              //Reset the `currentPoint` to 0 so that we can\n              //restart at the first point\n              currentPoint = 0; //Set the sprite to the first point\n\n              sprite.x = pathArray[0][0];\n              sprite.y = pathArray[0][1]; //Make the first new path\n\n              tween = makePath(currentPoint); //... and so it continues!\n            });\n          }\n        }\n    }; //Return the path tween to the main function\n\n\n    return tween;\n  } //Pass the tween back to the main program\n\n\n  return tween;\n}\nfunction walkCurve(sprite, //The sprite\npathArray) //Delay, in milliseconds, between sections\n{\n  var totalFrames = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 300;\n  var type = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [\"smoothstep\"];\n  var loop = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  var yoyo = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  var delayBeforeContinue = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\n  //Divide the `totalFrames` into sections for each part of the path\n  var frames = totalFrames / pathArray.length; //Set the current curve to 0, which will be the first one\n\n  var currentCurve = 0; //Make the first path\n\n  var tween = makePath(currentCurve);\n\n  function makePath(currentCurve) {\n    //Use the custom `followCurve` function to make\n    //a sprite follow a curve\n    var tween = followCurve(sprite, pathArray[currentCurve], frames, type); //When the tween is complete, advance the `currentCurve` by one.\n    //Add an optional delay between path segments, and then make the\n    //next path\n\n    tween.onComplete = function () {\n      currentCurve += 1;\n\n      if (currentCurve < pathArray.length) {\n        wait(delayBeforeContinue).then(function () {\n          tween = makePath(currentCurve);\n        });\n      } //If we've reached the end of the path, optionally\n      //loop and reverse it\n      else {\n          if (loop) {\n            if (yoyo) {\n              //Reverse order of the curves in the `pathArray` \n              pathArray.reverse(); //Reverse the order of the points in each curve\n\n              pathArray.forEach(function (curveArray) {\n                return curveArray.reverse();\n              });\n            } //After an optional delay, reset the sprite to the\n            //beginning of the path and make the next new path\n\n\n            wait(delayBeforeContinue).then(function () {\n              currentCurve = 0;\n              sprite.x = pathArray[0][0];\n              sprite.y = pathArray[0][1];\n              tween = makePath(currentCurve);\n            });\n          }\n        }\n    }; //Return the path tween to the main function\n\n\n    return tween;\n  } //Pass the tween back to the main program\n\n\n  return tween;\n}\n/*\r\nWait\r\n----\r\n\r\nLets you set up a timed sequence of events\r\n\r\n    wait(1000)\r\n      .then(() => console.log(\"One\"))\r\n      .then(() => wait(1000))\r\n      .then(() => console.log(\"Two\"))\r\n      .then(() => wait(1000))\r\n      .then(() => console.log(\"Three\"))\r\n\r\n*/\n\nfunction wait() {\n  var duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  return new Promise(function (resolve, reject) {\n    setTimeout(resolve, duration);\n  });\n}\n/*\r\n//This is the older version of the `slide` function that didn't use\r\n//`makeTween`\r\nexport function slide(sprite, endX, endY, frames, type, yoyo, delayBeforeRepeat) {\r\n\r\n  //Create a `tween` object to store the two x and y tweens\r\n  let tween = {};\r\n\r\n  //Create the x axis tween\r\n  tween.x = tweenProperty(\r\n    sprite, \"x\", sprite.x, endX, frames, type, yoyo, delayBeforeRepeat\r\n  );\r\n\r\n  //Create the y axis tween\r\n  tween.y = tweenProperty(\r\n    sprite, \"y\", sprite.x, endY, frames, type, yoyo, delayBeforeRepeat\r\n  );\r\n  \r\n  //Add a counter to the `tween` object to keep track of the\r\n  //number of tweens that have complete their actions.\r\n  tween.completionCounter = 0;\r\n\r\n  //`tween.completed` will be called each time one of the tweens\r\n  //finishes\r\n  tween.completed = () => {\r\n\r\n    //Add 1 to the `completionCounter`\r\n    tween.completionCounter += 1;\r\n\r\n    //If both tweens have finished, call the user-defined `onComplete`\r\n    //method, if it's been assigned. Reset the `completionCounter`\r\n    if (tween.completionCounter === 2) {\r\n      if (tween.onComplete) tween.onComplete();\r\n      tween.completionCounter = 0;\r\n    }\r\n  }; \r\n\r\n  //Add `onComplete` methods to both tweens\r\n  tween.x.onComplete = () => tween.completed();\r\n  tween.y.onComplete = () => tween.completed();\r\n  \r\n  //Add pause and play methods\r\n  tween.pause = () => {\r\n    tween.x.playing = false;\r\n    tween.y.playing = false;\r\n  };\r\n  tween.play = () => {\r\n    tween.x.playing = true;\r\n    tween.y.playing = true;\r\n  };\r\n\r\n  //Return this `tween` object\r\n  return tween;\r\n}\r\n*/\n\n/* \r\ntween\r\n-----\r\nA universal property tweening function\r\n`slide` arguments:\r\nsprite, destinationX, destinationY, speed\r\n*/\n\n/*\r\nexport function tweenProperty(sprite, property, startValue, endValue, speed, yoyo = true, delay = false) {\r\n\r\n  //Create the tween object\r\n  let tween = {};\r\n\r\n  //Use `tween.start` to make a new tween using the current\r\n  //end point values\r\n  tween.start = (startValue, endValue) => {\r\n    tween.startValue = startValue;\r\n    tween.endValue = endValue;\r\n    tween.playing = true;\r\n    tween.i = 0;\r\n\r\n    //Add the tween to the `tweens` array. The `tweens` array is\r\n    //updated on each frame\r\n    tweens.push(tween);\r\n  };\r\n\r\n  //Call `tween.start` to start the first tween\r\n  tween.start(startValue, endValue);\r\n\r\n  //The `update` method will be called on each frame by the game loop.\r\n  //This is what makes the tween move\r\n  tween.update = () => {\r\n    if (tween.playing) {\r\n\r\n      //If the sprite's property value is greater than the `endValue`\r\n      //tween the value down\r\n      if (tween.endValue < sprite[property]) {\r\n        if (sprite[property] > tween.endValue) {\r\n          sprite[property] -= speed;\r\n          if (sprite[property] < tween.endValue) sprite[property] = tween.endValue;\r\n        } else {\r\n          tween.end();\r\n        }\r\n      }\r\n\r\n      //If the sprite's property value is less than the `endValue`\r\n      //tween the value up\r\n      else {\r\n        if (sprite[property] < tween.endValue) {\r\n          sprite[property] += speed;\r\n          if (sprite[property] > tween.endValue) sprite[property] = tween.endValue;\r\n        } else {\r\n          tween.end();\r\n        }\r\n      }\r\n    }\r\n  };\r\n    \r\n  //The `end` method will be called when the tween is finsihed\r\n  tween.end = () => {\r\n    tween.playing = false;\r\n\r\n    //Call the tween's `onComplete` method, if it's been\r\n    //assigned\r\n    if (tween.onComplete) tween.onComplete();\r\n\r\n    //Remove the tween from the `tweens` array\r\n    tweens.splice(tweens.indexOf(tween), 1);\r\n\r\n    //If the tween's `yoyo` property is `true`, create a new tween\r\n    //using the same values, but use the current tween's alpha\r\n    //value as the next tween's alpha value \r\n    if (yoyo) {\r\n      wait(delay).then(\r\n        () => tween.start(tween.endValue, tween.startValue)\r\n      );\r\n    }\r\n  };\r\n\r\n  //Pause and play methods\r\n  tween.pause = () => {\r\n    tween.playing = false;\r\n  };\r\n  tween.play = () => {\r\n    tween.playing = true;\r\n  };\r\n  \r\n  //Return the tween object\r\n  return tween;\r\n}\r\n*/\n\n/* \r\nslide\r\n-----\r\nUse `slide` to ease a sprite to a new position.\r\n`slide` arguments:\r\nsprite, destinationX, destinationY, speed\r\n*/\n\n/*\r\nexport function slide(sprite, endX, endY, speed = 0.05, yoyo = false, delay = 0) {\r\n\r\n  //Create the tween object\r\n  let tween = {};\r\n\r\n  //Use `createTween` to make a new tween using the current\r\n  //end point values\r\n  createTween(endX, endY);\r\n  \r\n  //Return the tween object\r\n  return tween;\r\n\r\n  function createTween(endX, endY) {\r\n\r\n    //Capture the start and end points\r\n    tween.startX = sprite.x;\r\n    tween.startY = sprite.y;\r\n    tween.endX = endX;\r\n    tween.endY = endY;\r\n\r\n    //Set the tween's `playing` property to true\r\n    tween.playing = true;\r\n\r\n    //The tween's `update` function will be called once\r\n    //each frame inside the game loop\r\n    tween.update = () => {\r\n\r\n      //If the tween is playing, move it\r\n      if (tween.playing) {\r\n        let vx = tween.endX - sprite.x,\r\n            vy = tween.endY - sprite.y,\r\n            distance = Math.sqrt(vx * vx + vy * vy);\r\n\r\n        if (distance >= 0.5) {\r\n          sprite.x += vx * speed;\r\n          sprite.y += vy * speed;\r\n        } \r\n        \r\n        //If the tween has reached its destination, stop it\r\n        else {\r\n          sprite.x = tween.endX;\r\n          sprite.y = tween.endY;\r\n          tween.playing = false;\r\n\r\n          //Call the tween's `onComplete` method, if it's been\r\n          //assigned\r\n          if (tween.onComplete) tween.onComplete();\r\n\r\n          //Remove the tween from the `tweens` array\r\n          tweens.splice(tweens.indexOf(tween), 1);\r\n\r\n          //If the tween's `yoyo` property is true, create a new tween\r\n          //using the same values, but use the current tween's start\r\n          //point as the next tween's end point \r\n          if (yoyo) {\r\n            wait(delay).then(\r\n              () => createTween(tween.startX, tween.startY)\r\n            );\r\n          };\r\n        }\r\n      }\r\n    };\r\n\r\n    //Give the tween `pause` and `play` methods\r\n    tween.pause = () => {\r\n      tween.playing = false;\r\n    };\r\n    tween.play = () => {\r\n      tween.playing = true;\r\n    };\r\n\r\n    //Add the tween to the `tweens` array. The `tweens` array is\r\n    //updated on each frame\r\n    tweens.push(tween);\r\n  }\r\n}\r\n*/\n\n/*\r\nfade\r\n----\r\nUse `fade` to fade-in or fade-out any sprite.\r\n`fade` arguments:\r\nsprite, speed, finalValue\r\n*/\n\n/*\r\nexport function fade(sprite, endAlpha = 0, speed = 0.02, yoyo = true, delay = 1000) {\r\n  //Create the tween object\r\n  let tween = {};\r\n\r\n  //Use `createTween` to make a new tween using the current\r\n  //end point values\r\n  createTween(endAlpha);\r\n  \r\n  //Return the tween object\r\n  return tween;\r\n\r\n  function createTween(endAlpha) {\r\n    tween.startAlpha = sprite.alpha;\r\n    tween.endAlpha = endAlpha;\r\n    tween.playing = true;\r\n    tween.update = () => {\r\n      if (tween.playing) {\r\n        //Fade out\r\n        if (tween.endAlpha < sprite.alpha) {\r\n          if (sprite.alpha > tween.endAlpha) {\r\n            sprite.alpha -= speed;\r\n            if (sprite.alpha < tween.endAlpha) sprite.alpha = tween.endAlpha;\r\n          } else {\r\n            tween.playing = false;\r\n            if (tween.onComplete) tween.onComplete();\r\n            //Remove the tween from the `tweens` array\r\n            tweens.splice(tweens.indexOf(tween), 1);\r\n          }\r\n        }\r\n        else {\r\n          //Fade in\r\n          if (sprite.alpha < tween.endAlpha) {\r\n            sprite.alpha += speed;\r\n            if (sprite.alpha > tween.endAlpha) sprite.alpha = tween.endAlpha;\r\n          } else {\r\n            tween.playing = false;\r\n            //Call the tween's `onComplete` method, if it's been\r\n            //assigned\r\n            if (tween.onComplete) tween.onComplete();\r\n\r\n            //Remove the tween from the `tweens` array\r\n            tweens.splice(tweens.indexOf(tween), 1);\r\n\r\n            //If the tween's `yoyo` property is true, create a new tween\r\n            //using the same values, but use the current tween's alpha\r\n            //value as the next tween's alpha value \r\n            if (yoyo) {\r\n              wait(delay).then(\r\n                () => createTween(tween.startAlpha)\r\n              );\r\n            };\r\n          }\r\n        }\r\n      }\r\n    };\r\n\r\n    //Pause and play methods\r\n    tween.pause = () => {\r\n      tween.playing = false;\r\n    };\r\n    tween.play = () => {\r\n      tween.playing = true;\r\n    };\r\n\r\n    //Add the tween to the `tweens` array. The `tweens` array is\r\n    //updated on each frame\r\n    tweens.push(tween);\r\n  }\r\n}\r\n*/\n\n//# sourceURL=webpack:///./src/js/library/tween.js?");

/***/ }),

/***/ "./src/js/library/utilities.js":
/*!*************************************!*\
  !*** ./src/js/library/utilities.js ***!
  \*************************************/
/*! exports provided: assets, outsideBounds, contain, distance, followEase, easeProperty, followConstant, angle, rotateSprite, rotatePoint, randomInt, randomFloat, shoot, wait, move, slide, fade */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"assets\", function() { return assets; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"outsideBounds\", function() { return outsideBounds; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"contain\", function() { return contain; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"distance\", function() { return distance; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"followEase\", function() { return followEase; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"easeProperty\", function() { return easeProperty; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"followConstant\", function() { return followConstant; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"angle\", function() { return angle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotateSprite\", function() { return rotateSprite; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotatePoint\", function() { return rotatePoint; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"randomInt\", function() { return randomInt; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"randomFloat\", function() { return randomFloat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"shoot\", function() { return shoot; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"wait\", function() { return wait; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"move\", function() { return move; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"slide\", function() { return slide; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fade\", function() { return fade; });\n/* harmony import */ var _library_sound__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../library/sound */ \"./src/js/library/sound.js\");\n/* \r\nutilities.js\r\n==============\r\n\r\nThis JavaScript file contains useful functions for\r\nadding interactivity to sprites. See the sprites.js file for\r\nsprite prototype objects can use this code\r\n\r\n*/\n//Dependencies\n\n/*\r\nassets\r\n------\r\n\r\nThis is an object to help you load and use game assets, like images, fonts and sounds,\r\nand texture atlases. \r\nHere's how to use to load an image, a font and a texture atlas:\r\n\r\n    assets.load([\r\n      \"images/cat.png\",\r\n      \"fonts/puzzler.otf\",\r\n      \"images/animals.json\",\r\n    ]).then(() => setup());\r\n    \r\nWhen all the assets have finsihed loading, the makeSprites function\r\nwill run. (Replace makeSprites with an other function you need).\r\nWhen you've loaded an asset, you can acccess it like this:\r\n\r\n    imageObject = assets[\"images/cat.png\"];\r\n\r\nAccess individual frames in a texture atlas using the frame's name, like this:\r\n\r\n    frame = assets[\"hedgehog.png\"];\r\n\r\n(Just use the image name without the extension.)\r\n\r\n*/\n\nvar assets = {\n  //Properties to help track the assets being loaded\n  toLoad: 0,\n  loaded: 0,\n  //File extensions for different types of assets\n  imageExtensions: [\"png\", \"jpg\", \"gif\"],\n  fontExtensions: [\"ttf\", \"otf\", \"ttc\", \"woff\"],\n  jsonExtensions: [\"json\"],\n  audioExtensions: [\"mp3\", \"ogg\", \"wav\", \"webm\"],\n  //The `load` method creates and loads all the assets. Use it like this:\n  //`assets.load([\"images/anyImage.png\", \"fonts/anyFont.otf\"]);`\n  load: function load(sources) {\n    var _this = this;\n\n    //The `load` method will return a Promise when everything has\n    //loaded\n    return new Promise(function (resolve) {\n      //The `loadHandler` counts the number of assets loaded, compares\n      //it to the total number of assets that need to be loaded, and\n      //resolves the Promise when everything has loaded\n      var loadHandler = function loadHandler() {\n        _this.loaded += 1;\n        console.log(_this.loaded); //Check whether everything has loaded\n\n        if (_this.toLoad === _this.loaded) {\n          //Reset `toLoad` and `loaded` to `0` so you can use them\n          //to load more assets later if you need to\n          _this.toLoad = 0;\n          _this.loaded = 0;\n          console.log(\"Assets finished loading\"); //Resolve the promise\n\n          resolve();\n        }\n      }; //Display a console message to confirm that the assets are\n      //being loaded\n\n\n      console.log(\"Loading assets...\"); //Find the number of files that need to be loaded\n\n      _this.toLoad = sources.length; //Loop through all the source file names and find out how\n      //they should be interpreted\n\n      sources.forEach(function (source) {\n        //Find the file extension of the asset\n        var extension = source.split(\".\").pop(); //Load images that have file extensions that match \n        //the imageExtensions array\n\n        if (_this.imageExtensions.indexOf(extension) !== -1) {\n          _this.loadImage(source, loadHandler);\n        } //Load fonts \n        else if (_this.fontExtensions.indexOf(extension) !== -1) {\n            _this.loadFont(source, loadHandler);\n          } //Load JSON files  \n          else if (_this.jsonExtensions.indexOf(extension) !== -1) {\n              _this.loadJson(source, loadHandler);\n            } //Load audio files  \n            else if (_this.audioExtensions.indexOf(extension) !== -1) {\n                _this.loadSound(source, loadHandler);\n              } //Display a message if a file type isn't recognized\n              else {\n                  console.log(\"File type not recognized: \" + source);\n                } //Here's the newer ES6 way of achieving the same thing.\n        //At the time of writing there were some browser bugs\n        //associated with this, so I haven't used in in the \n        //production code\n\n        /*\r\n        //Load images that have file extensions that match \r\n        //the imageExtensions array\r\n        if (this.imageExtensions.find(x => x === extension)) {\r\n          this.loadImage(source, loadHandler);\r\n        }\r\n        //Load fonts \r\n        else if (this.fontExtensions.find(x => x === extension)) {\r\n          this.loadFont(source, loadHandler);\r\n        }\r\n        //Load JSON files  \r\n        else if (this.jsonExtensions.find(x => x === extension)) {\r\n          this.loadJson(source, loadHandler);\r\n        }\r\n        //Load audio files  \r\n        else if (this.audioExtensions.find(x => x === extension)) {\r\n          this.loadSound(source, loadHandler);\r\n        }\r\n        */\n\n      });\n    });\n  },\n  loadImage: function loadImage(source, loadHandler) {\n    //Create a new image and call the `loadHandler` when the image\n    //file has loaded\n    var image = new Image();\n    image.addEventListener(\"load\", loadHandler, false); //Assign the image as a property of the `assets` object so\n    //you can access it like this: `assets[\"path/imageName.png\"]`\n\n    this[source] = image; //Alternatively, if you only want the file name without the full\n    //path, you can get it like this:\n    //image.name = source.split(\"/\").pop();\n    //this[image.name] = image; \n    //This will allow you to access the image like this:\n    //assets[\"imageName.png\"];\n    //Set the image's `src` property to start loading the image\n\n    image.src = source;\n  },\n  loadFont: function loadFont(source, loadHandler) {\n    //Use the font's file name as the `fontFamily` name\n    var fontFamily = source.split(\"/\").pop().split(\".\")[0]; //Append an `@afont-face` style rule to the head of the HTML\n    //document. It's kind of a hack, but until HTML5 has a\n    //proper font loading API, it will do for now\n\n    var newStyle = document.createElement(\"style\");\n    var fontFace = \"@font-face {font-family: '\" + fontFamily + \"'; src: url('\" + source + \"');}\";\n    newStyle.appendChild(document.createTextNode(fontFace));\n    document.head.appendChild(newStyle); //Tell the `loadHandler` we're loading a font\n\n    loadHandler();\n  },\n  loadJson: function loadJson(source, loadHandler) {\n    var _this2 = this;\n\n    //Create a new `xhr` object and an object to store the file\n    var xhr = new XMLHttpRequest(); //Use xhr to load the JSON file\n\n    xhr.open(\"GET\", source, true); //Tell xhr that it's a text file\n\n    xhr.responseType = \"text\"; //Create an `onload` callback function that\n    //will handle the file loading    \n\n    xhr.onload = function (event) {\n      //Check to make sure the file has loaded properly\n      if (xhr.status === 200) {\n        //Convert the JSON data file into an ordinary object\n        var file = JSON.parse(xhr.responseText); //Get the file name\n\n        file.name = source; //Assign the file as a property of the assets object so\n        //you can access it like this: `assets[\"file.json\"]`\n\n        _this2[file.name] = file; //Texture atlas support:\n        //If the JSON file has a `frames` property then \n        //it's in Texture Packer format\n\n        if (file.frames) {\n          //Create the tileset frames\n          _this2.createTilesetFrames(file, source, loadHandler);\n        } else {\n          //Alert the load handler that the file has loaded\n          loadHandler();\n        }\n      }\n    }; //Send the request to load the file\n\n\n    xhr.send();\n  },\n  createTilesetFrames: function createTilesetFrames(file, source, loadHandler) {\n    var _this3 = this;\n\n    //Get the tileset image's file path\n    var baseUrl = source.replace(/[^\\/]*$/, \"\"); //Here's how this regular expression works:\n    //http://stackoverflow.com/questions/7601674/id-like-to-remove-the-filename-from-a-path-using-javascript\n    //Use the `baseUrl` and `image` name property from the JSON \n    //file's `meta` object to construct the full image source path \n\n    var imageSource = baseUrl + file.meta.image; //The image's load handler\n\n    var imageLoadHandler = function imageLoadHandler() {\n      //Assign the image as a property of the `assets` object so\n      //you can access it like this:\n      //`assets[\"images/imageName.png\"]`\n      _this3[imageSource] = image; //Loop through all the frames\n\n      Object.keys(file.frames).forEach(function (frame) {\n        //The `frame` object contains all the size and position\n        //data for each sub-image.\n        //Add the frame data to the asset object so that you\n        //can access it later like this: `assets[\"frameName.png\"]`\n        _this3[frame] = file.frames[frame]; //Get a reference to the source so that it will be easy for\n        //us to access it later\n\n        _this3[frame].source = image;\n      }); //Alert the load handler that the file has loaded\n\n      loadHandler();\n    }; //Load the tileset image\n\n\n    var image = new Image();\n    image.addEventListener(\"load\", imageLoadHandler, false);\n    image.src = imageSource;\n  },\n  loadSound: function loadSound(source, loadHandler) {\n    //Create a sound sprite and alert the `loadHandler`\n    //when the sound file has loaded.\n    //\n    var sound = Object(_library_sound__WEBPACK_IMPORTED_MODULE_0__[\"makeSound\"])(source, loadHandler); //Get the sound file name.\n\n    sound.name = source; //If you just want to extract the file name with the\n    //extension, you can do it like this:\n    //soundSprite.name = source.split(\"/\").pop();\n    //Assign the sound as a property of the assets object so\n    //we can access it like this: `assets[\"sounds/sound.mp3\"]`.\n\n    this[sound.name] = sound;\n  }\n};\n/*\r\n\r\noutsideBounds\r\n-------------\r\n\r\nCheck whether sprite is completely outside of\r\na boundary\r\n\r\n*/\n\nfunction outsideBounds(sprite, bounds) {\n  var extra = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n  var x = bounds.x,\n      y = bounds.y,\n      width = bounds.width,\n      height = bounds.height; //The `collision` object is used to store which\n  //side of the containing rectangle the sprite hits\n\n  var collision; //Left\n\n  if (sprite.x < x - sprite.width) {\n    collision = \"left\";\n  } //Top\n\n\n  if (sprite.y < y - sprite.height) {\n    collision = \"top\";\n  } //Right\n\n\n  if (sprite.x > width) {\n    collision = \"right\";\n  } //Bottom\n\n\n  if (sprite.y > height) {\n    collision = \"bottom\";\n  } //The `extra` function runs if there was a collision\n  //and `extra` has been defined\n\n\n  if (collision && extra) extra(collision); //Return the `collision` object\n\n  return collision;\n}\n;\n/*\r\n\r\ncontain\r\n-------\r\n\r\nKeep a sprite contained inside a boundary\r\n\r\n*/\n\nfunction contain(sprite, bounds) {\n  var bounce = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var extra = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n  var x = bounds.x,\n      y = bounds.y,\n      width = bounds.width,\n      height = bounds.height; //The `collision` object is used to store which\n  //side of the containing rectangle the sprite hits\n\n  var collision; //Left\n\n  if (sprite.x < x) {\n    //Bounce the sprite if `bounce` is true\n    if (bounce) sprite.vx *= -1; //If the sprite has `mass`, let the mass\n    //affect the sprite's velocity\n\n    if (sprite.mass) sprite.vx /= sprite.mass;\n    sprite.x = x;\n    collision = \"left\";\n  } //Top\n\n\n  if (sprite.y < y) {\n    if (bounce) sprite.vy *= -1;\n    if (sprite.mass) sprite.vy /= sprite.mass;\n    sprite.y = y;\n    collision = \"top\";\n  } //Right\n\n\n  if (sprite.x + sprite.width > width) {\n    if (bounce) sprite.vx *= -1;\n    if (sprite.mass) sprite.vx /= sprite.mass;\n    sprite.x = width - sprite.width;\n    collision = \"right\";\n  } //Bottom\n\n\n  if (sprite.y + sprite.height > height) {\n    if (bounce) sprite.vy *= -1;\n    if (sprite.mass) sprite.vy /= sprite.mass;\n    sprite.y = height - sprite.height;\n    collision = \"bottom\";\n  } //The `extra` function runs if there was a collision\n  //and `extra` has been defined\n\n\n  if (collision && extra) extra(collision); //Return the `collision` object\n\n  return collision;\n}\n;\n/*\r\ndistance\r\n----------------\r\n\r\nFind the distance in pixels between two sprites.\r\nParameters: \r\na. A sprite object with `centerX` and `centerY` properties. \r\nb. A sprite object with `centerX` and `centerY` properties. \r\nThe function returns the number of pixels distance between the sprites.\r\n\r\n*/\n\nfunction distance(s1, s2) {\n  var vx = s2.centerX - s1.centerX,\n      vy = s2.centerY - s1.centerY;\n  return Math.sqrt(vx * vx + vy * vy);\n}\n/*\r\nfollowEase\r\n----------------\r\n\r\nMake a sprite ease to the position of another sprite.\r\nParameters: \r\na. A sprite object with `centerX` and `centerY` properties. This is the `follower`\r\nsprite.\r\nb. A sprite object with `centerX` and `centerY` properties. This is the `leader` sprite that\r\nthe follower will chase\r\nc. The easing value, such as 0.3. A higher number makes the follower move faster\r\n\r\n*/\n\nfunction followEase(follower, leader, speed) {\n  //Figure out the distance between the sprites\n  var vx = leader.centerX - follower.centerX,\n      vy = leader.centerY - follower.centerY,\n      distance = Math.sqrt(vx * vx + vy * vy); //Move the follower if it's more than 1 pixel\n  //away from the leader\n\n  if (distance >= 1) {\n    follower.x += vx * speed;\n    follower.y += vy * speed;\n  }\n}\nvar easeProperty = function easeProperty(start, end, speed) {\n  //Calculate the distance\n  var distance = end - start; //Move the follower if it's more than 1 pixel \n  //away from the leader\n\n  if (distance >= 1) {\n    return distance * speed;\n  } else {\n    return 0;\n  }\n};\n/*\r\nfollowConstant\r\n----------------\r\n\r\nMake a sprite move towards another sprite at a regular speed.\r\nParameters: \r\na. A sprite object with `center.x` and `center.y` properties. This is the `follower`\r\nsprite.\r\nb. A sprite object with `center.x` and `center.y` properties. This is the `leader` sprite that\r\nthe follower will chase\r\nc. The speed value, such as 3. The is the pixels per frame that the sprite will move. A higher number makes the follower move faster.\r\n\r\n*/\n\nfunction followConstant(follower, leader, speed) {\n  //Figure out the distance between the sprites\n  var vx = leader.centerX - follower.centerX,\n      vy = leader.centerY - follower.centerY,\n      distance = Math.sqrt(vx * vx + vy * vy); //Move the follower if it's more than 1 move\n  //away from the leader\n\n  if (distance >= speed) {\n    follower.x += vx / distance * speed;\n    follower.y += vy / distance * speed;\n  }\n}\n/*\r\nangle\r\n-----\r\n\r\nReturn the angle in Radians between two sprites.\r\nParameters: \r\na. A sprite object with `centerX` and `centerY` properties.\r\nb. A sprite object with `centerX` and `centerY` properties.\r\nYou can use it to make a sprite rotate towards another sprite like this:\r\n\r\n    box.rotation = angle(box, pointer);\r\n\r\n*/\n\nvar angle = function angle(s1, s2) {\n  return Math.atan2(s2.centerY - s1.centerY, s2.centerX - s1.centerX);\n}; //### rotateAround\n//Make a sprite rotate around another sprite\n\nfunction rotateSprite(rotatingSprite, centerSprite, distance, angle) {\n  rotatingSprite.x = centerSprite.centerX - rotatingSprite.parent.x + distance * Math.cos(angle) - rotatingSprite.halfWidth;\n  rotatingSprite.y = centerSprite.centerY - rotatingSprite.parent.y + distance * Math.sin(angle) - rotatingSprite.halfWidth;\n} //### rotatePoint\n//Make a point rotate around another point\n\nfunction rotatePoint(pointX, pointY, distanceX, distanceY, angle) {\n  var point = {};\n  point.x = pointX + Math.cos(angle) * distanceX;\n  point.y = pointY + Math.sin(angle) * distanceY;\n  return point;\n}\n;\n/*\r\nrandomInt\r\n---------\r\n\r\nReturn a random integer between a minimum and maximum value\r\nParameters: \r\na. An integer.\r\nb. An integer.\r\nHere's how you can use it to get a random number between, 1 and 10:\r\n\r\n    randomInt(1, 10);\r\n\r\n*/\n\nvar randomInt = function randomInt(min, max) {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n/*\r\nrandomFloat\r\n---------\r\n\r\nReturn a random floating point number between a minimum and maximum value\r\nParameters: \r\na. Any number.\r\nb. Any number.\r\nHere's how you can use it to get a random floating point number between, 1 and 10:\r\n\r\n    randomFloat(1, 10);\r\n\r\n*/\n\nvar randomFloat = function randomFloat(min, max) {\n  return min + Math.random() * (max - min);\n};\n/*\r\nshoot\r\n---------\r\n\r\n\r\n*/\n\nfunction shoot(shooter, angle, offsetFromCenter, bulletSpeed, bulletArray, bulletSprite) {\n  //Make a new sprite using the user-supplied `bulletSprite` function\n  var bullet = bulletSprite(); //Set the bullet's start point\n\n  bullet.x = shooter.centerX - bullet.halfWidth + offsetFromCenter * Math.cos(angle);\n  bullet.y = shooter.centerY - bullet.halfHeight + offsetFromCenter * Math.sin(angle); //Set the bullet's velocity\n\n  bullet.vx = Math.cos(angle) * bulletSpeed;\n  bullet.vy = Math.sin(angle) * bulletSpeed; //Push the bullet into the `bulletArray`\n\n  bulletArray.push(bullet);\n}\n/*\r\nWait\r\n----\r\n\r\nLets you set up a timed sequence of events\r\n\r\n    wait(1000)\r\n      .then(() => console.log(\"One\"))\r\n      .then(() => wait(1000))\r\n      .then(() => console.log(\"Two\"))\r\n      .then(() => wait(1000))\r\n      .then(() => console.log(\"Three\"))\r\n\r\n*/\n\nfunction wait() {\n  var duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  return new Promise(function (resolve, reject) {\n    setTimeout(resolve, duration);\n  });\n}\n/*\r\nMove\r\n----\r\n\r\nMove a sprite by adding it's velocity to it's position\r\n\r\n    move(sprite);\r\n*/\n\nfunction move() {\n  if (arguments.length === 1) {\n    var s = arguments.length <= 0 ? undefined : arguments[0];\n    s.x += s.vx;\n    s.y += s.vy;\n  } else {\n    for (var i = 0; i < arguments.length; i++) {\n      var _s = i < 0 || arguments.length <= i ? undefined : arguments[i];\n\n      _s.x += _s.vx;\n      _s.y += _s.vy;\n    }\n  }\n} //Tween functions\n\nvar slide = function slide(sprite, x, y, time) {\n  var tween = new TWEEN.Tween({\n    x: sprite.x,\n    y: sprite.y\n  }).to({\n    x: x,\n    y: y\n  }, time);\n  tween.easing(TWEEN.Easing.Circular.Out);\n  tween.onUpdate(function () {\n    sprite.x = this.x;\n    sprite.y = this.y;\n  });\n  tween.start();\n  return tween;\n};\nvar fade = function fade(sprite, alpha, time) {\n  var tween = new TWEEN.Tween({\n    alpha: sprite.alpha\n  }).to({\n    alpha: alpha\n  }, time);\n  tween.easing(TWEEN.Easing.Linear.None);\n  tween.onUpdate(function () {\n    sprite.alpha = this.alpha;\n  });\n  tween.start();\n};\n\n//# sourceURL=webpack:///./src/js/library/utilities.js?");

/***/ }),

/***/ "./src/js/loadBoxes.js":
/*!*****************************!*\
  !*** ./src/js/loadBoxes.js ***!
  \*****************************/
/*! exports provided: loadBoxes */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"loadBoxes\", function() { return loadBoxes; });\nfunction loadBoxes() {\n  var boxes = __webpack_require__(/*! ../../boxes.json */ \"./boxes.json\");\n\n  return boxes;\n}\n\n//# sourceURL=webpack:///./src/js/loadBoxes.js?");

/***/ }),

/***/ "./src/js/main.js":
/*!************************!*\
  !*** ./src/js/main.js ***!
  \************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _library_display__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./library/display */ \"./src/js/library/display.js\");\n/* harmony import */ var _library_utilities__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./library/utilities */ \"./src/js/library/utilities.js\");\n/* harmony import */ var _library_interactive__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./library/interactive */ \"./src/js/library/interactive.js\");\n/* harmony import */ var _library_collision__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./library/collision */ \"./src/js/library/collision.js\");\n/* harmony import */ var _library_tween__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./library/tween */ \"./src/js/library/tween.js\");\n/* harmony import */ var _order__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./order */ \"./src/js/order.js\");\n/* harmony import */ var _loadBoxes__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./loadBoxes */ \"./src/js/loadBoxes.js\");\n/* harmony import */ var _GenerateBox__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./GenerateBox */ \"./src/js/GenerateBox.js\");\n/* harmony import */ var _box__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./box */ \"./src/js/box.js\");\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/*******************************************************************************************************\r\n\r\n███╗   ██╗██╗██╗  ██╗ ██████╗ ███╗   ██╗            ****************************************************                 \r\n████╗  ██║██║╚██╗██╔╝██╔═══██╗████╗  ██║            * This application is simulation of crane storage \r\n██╔██╗ ██║██║ ╚███╔╝ ██║   ██║██╔██╗ ██║            * sistem's controller.                 \r\n██║╚██╗██║██║ ██╔██╗ ██║   ██║██║╚██╗██║            * Free to use for non commercial usage.  \r\n██║ ╚████║██║██╔╝ ██╗╚██████╔╝██║ ╚████║            * Feel free to contact me for customization. \r\n╚═╝  ╚═══╝╚═╝╚═╝  ╚═╝ ╚═════╝ ╚═╝  ╚═══╝            *                 \r\n ██████╗██████╗  █████╗ ███╗   ██╗███████╗          *      live demo at: nixonsresume.online\r\n██╔════╝██╔══██╗██╔══██╗████╗  ██║██╔════╝          ****************************************************                 \r\n██║     ██████╔╝███████║██╔██╗ ██║█████╗                             \r\n██║     ██╔══██╗██╔══██║██║╚██╗██║██╔══╝                             ~\r\n╚██████╗██║  ██║██║  ██║██║ ╚████║███████╗                           \r\n ╚═════╝╚═╝  ╚═╝╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝                           \r\n ██████╗ ██████╗ ███╗   ██╗████████╗██████╗  ██████╗ ██╗     ██╗     \r\n██╔════╝██╔═══██╗████╗  ██║╚══██╔══╝██╔══██╗██╔═══██╗██║     ██║     \r\n██║     ██║   ██║██╔██╗ ██║   ██║   ██████╔╝██║   ██║██║     ██║     \r\n██║     ██║   ██║██║╚██╗██║   ██║   ██╔══██╗██║   ██║██║     ██║     \r\n╚██████╗╚██████╔╝██║ ╚████║   ██║   ██║  ██║╚██████╔╝███████╗███████╗\r\n ╚═════╝ ╚═════╝ ╚═╝  ╚═══╝   ╚═╝   ╚═╝  ╚═╝ ╚═════╝ ╚══════╝╚══════╝\r\n*******************************************************************************************************\r\nLast Update: 12/2/2020\r\n\r\nTodos: \r\n\r\nSelect the box - display the box info\r\nBuild the in and outbound\r\nEase the movement to the station\r\nMake a div for adding new boxes to the storage\r\nMake order array*(ok) and complete the orders one by one\r\ncrane movement sound\r\nmaxspeed of the crane and the twister\r\nif pickup location is selected show a cancel button to cancel the order creation\r\nALL OF THE TEXTS TRANSFORM TO DATA CARRIER OBJECT\r\n\r\n*******************************************************************************************************/\n\n\n\n\n\n\n\n\n //Load assets\n\n_library_utilities__WEBPACK_IMPORTED_MODULE_1__[\"assets\"].load([\"./json/craneImg.json\"]).then(function () {\n  return setup();\n}); //Handling things outsicde of the app - divs etc\n\nvar overlay = document.getElementById(\"overlay\");\ndocument.getElementById(\"send-box-cancel\").addEventListener(\"click\", function () {\n  overlay.style.visibility = \"hidden\";\n});\nvar indexLocSent = document.getElementById(\"indLocation\");\nvar generateBoxmessage = document.getElementById(\"boxMessage\");\ndocument.getElementById(\"send-box\").addEventListener(\"click\", function () {\n  makeInboundBox(generateBoxmessage.value, indexLocSent.value, -1);\n  overlay.style.visibility = \"hidden\";\n}); // Declare shared variables\n\nvar pointer,\n    canvas,\n    crane,\n    twister,\n    box,\n    craneAll,\n    textBox,\n    textSpeed,\n    textTwisterY,\n    textCraneX,\n    textTwisterSpeed,\n    rack,\n    texttargetLocation,\n    inboundJob = false,\n    order,\n    dot,\n    inbound,\n    outbound,\n    inboundText,\n    outboundTExt,\n    addBoxButton;\nvar orders = []; //Array used to store the orders\n\nvar pickUpLocation = []; //Array used to store the pickup location x and y until the destination is not selected\n\nvar destinationLocation = []; //Array used to store the destination x and y \n\nvar boxesArray = []; // Array which will store the boxes\n//FUNCTIONS LATER TO EXPORT\n\nvar makeBox = function makeBox(message, currentLocI) {\n  var box = Object(_library_display__WEBPACK_IMPORTED_MODULE_0__[\"sprite\"])(_library_utilities__WEBPACK_IMPORTED_MODULE_1__[\"assets\"][\"box.png\"]);\n  box.message = message;\n  box.name = \"box\";\n  box.locationIndex = currentLocI;\n  boxesArray.push(box);\n};\n\nvar makeInboundBox = function makeInboundBox(message, destino, currentLocI) {\n  var box = Object(_library_display__WEBPACK_IMPORTED_MODULE_0__[\"sprite\"])(_library_utilities__WEBPACK_IMPORTED_MODULE_1__[\"assets\"][\"box.png\"]);\n  box.message = message;\n  box.name = \"box\";\n  box.destination = destino;\n  box.locationIndex = currentLocI;\n  box.waiting = true;\n  boxesArray.push(box);\n}; // Setup everything before playing\n\n\nfunction setup() {\n  // UNCOMMENT FOR DRIVE WITH ARROWS\n  //keypress\n  var left = Object(_library_interactive__WEBPACK_IMPORTED_MODULE_2__[\"keyboard\"])(37);\n\n  left.press = function () {\n    crane.moveLeft = true;\n  };\n\n  left.release = function () {\n    crane.moveLeft = false;\n  };\n\n  var right = Object(_library_interactive__WEBPACK_IMPORTED_MODULE_2__[\"keyboard\"])(39);\n\n  right.press = function () {\n    crane.moveRight = true;\n  };\n\n  right.release = function () {\n    crane.moveRight = false;\n  };\n\n  var up = Object(_library_interactive__WEBPACK_IMPORTED_MODULE_2__[\"keyboard\"])(38);\n\n  up.press = function () {\n    if (twister.y > 50) {\n      twister.moveUp = true;\n    }\n  };\n\n  up.release = function () {\n    twister.moveUp = false;\n  };\n\n  var down = Object(_library_interactive__WEBPACK_IMPORTED_MODULE_2__[\"keyboard\"])(40);\n\n  down.press = function () {\n    if (twister.y < crane.height - 120) twister.moveDown = true;\n  };\n\n  down.release = function () {\n    twister.moveDown = false;\n  };\n\n  var stop = Object(_library_interactive__WEBPACK_IMPORTED_MODULE_2__[\"keyboard\"])(32);\n\n  stop.press = function () {\n    craneAll.vx = 0;\n    twister.vy = 0;\n  }; //make the canvas\n\n\n  canvas = Object(_library_display__WEBPACK_IMPORTED_MODULE_0__[\"makeCanvas\"])(1600, 1000);\n  canvas.style.backgroundColor = \"grey\";\n  _library_display__WEBPACK_IMPORTED_MODULE_0__[\"stage\"].width = window.innerWidth / canvas.width;\n  _library_display__WEBPACK_IMPORTED_MODULE_0__[\"stage\"].height = window.innerHeight / canvas.height;\n  var scaleX, scaleY, scale, center;\n  scaleX = window.innerWidth / canvas.width;\n  scaleY = window.innerHeight / canvas.height;\n  scale = Math.min(scaleX, scaleY);\n  canvas.style.transformOrigin = \"0 0\";\n  canvas.style.transform = \"scale(\" + scale + \")\";\n  canvas.style.paddingLeft = 0;\n  canvas.style.paddingRight = 0;\n  canvas.style.paddingTop = 0;\n  canvas.style.paddingBottom = 0;\n  canvas.style.display = \"block\";\n  pointer = Object(_library_interactive__WEBPACK_IMPORTED_MODULE_2__[\"makePointer\"])(canvas);\n  var box = Object(_library_display__WEBPACK_IMPORTED_MODULE_0__[\"sprite\"])(_library_utilities__WEBPACK_IMPORTED_MODULE_1__[\"assets\"][\"box.png\"]);\n  box.visible = false;\n  pointer.scale = scale;\n  scale = scale; //Make and assign boxes from boxesLocations array to the locations \n\n  var boxes = Object(_loadBoxes__WEBPACK_IMPORTED_MODULE_6__[\"loadBoxes\"])();\n  boxes.boxes.forEach(function (el) {\n    makeBox(el.message, el.LI);\n  }); // making the rack and the locations\n\n  var locationIndex = 0;\n  rack = Object(_library_display__WEBPACK_IMPORTED_MODULE_0__[\"grid\"])(27, 20, box.width + 2, box.height + 5, true, 0, 0, function () {\n    var location = Object(_library_display__WEBPACK_IMPORTED_MODULE_0__[\"rectangle\"])(box.width - 1, box.height - 1, \"black\");\n    location.index = locationIndex++;\n    location.occupied = false;\n    location.selected = false;\n    location.name = \"rack\";\n    boxesArray.forEach(function (b) {\n      if (location.index == b.locationIndex) {\n        location.addChild(b);\n        location.occupied = true;\n      }\n    });\n    return location;\n  });\n  rack.setPosition(5 * box.width, 2 * box.height); // General properties of the crane\n\n  crane = Object(_library_display__WEBPACK_IMPORTED_MODULE_0__[\"sprite\"])(_library_utilities__WEBPACK_IMPORTED_MODULE_1__[\"assets\"][\"crane.png\"]), crane.accelerationX = 0.01;\n  crane.frictionX = 0.93;\n  crane.speed = 0.13;\n  crane.pivotX = 62;\n  crane.moveRight = false;\n  crane.moveLeft = false; // General movement properties of the crane\n\n  twister = Object(_library_display__WEBPACK_IMPORTED_MODULE_0__[\"sprite\"])(_library_utilities__WEBPACK_IMPORTED_MODULE_1__[\"assets\"][\"twister.png\"]);\n  twister.x = crane.pivotX;\n  twister.y = crane.height - 110;\n  twister.accelerationY = 0.01;\n  twister.frictionY = 0.91;\n  twister.speed = 0.013;\n  twister.moveUp = false;\n  twister.moveDown = false;\n  twister.busy = false;\n  twister.boxFound = false; // Make the inbound and outbound stations\n\n  inbound = Object(_library_display__WEBPACK_IMPORTED_MODULE_0__[\"rectangle\"])(200, 30, \"white\", \"white\");\n  inbound.x = -200;\n  inbound.y = 200;\n  inbound.name = \"inbound\";\n  inbound.index = -1;\n  outbound = Object(_library_display__WEBPACK_IMPORTED_MODULE_0__[\"rectangle\"])(200, 30, \"white\", \"white\");\n  outbound.x = -200;\n  outbound.y = 300;\n  outbound.name = \"outbound\";\n  outbound.index = -2; // make buttons for add new boxes\n\n  addBoxButton = Object(_library_display__WEBPACK_IMPORTED_MODULE_0__[\"rectangle\"])(70, 20, \"grey\", \"black\", 2, 20, 20);\n  addBoxButton.interactive = true;\n  addBoxButton.text = Object(_library_display__WEBPACK_IMPORTED_MODULE_0__[\"text\"])(\"Create Box\", \"arial\", \"black\", addBoxButton.x, addBoxButton.centerY); // make the relations\n\n  rack.addChild(inbound);\n  rack.addChild(outbound);\n  crane.addChild(twister);\n  craneAll = Object(_library_display__WEBPACK_IMPORTED_MODULE_0__[\"group\"])(crane, twister); //the box displaying the informarion\n  //////////////////////////// RECREATE ALL DATA DISPLAY AND INFOS\n  //     textBox = rectangle(canvas.width-50,50,\"lightgrey\",\"grey\")\n  //     textBox.x = 25\n  //     textBox.y = canvas.height - 75\n  // /* TODO> ALL OF THE TEXTS TRANSFORM TO DATA CARRIER OBJECT */ \n  // //The texts displayed in the infobox  \n  //     textSpeed = text()\n  //     textTwisterY = text()\n  //     textCraneX = text()\n  //     textTwisterSpeed = text()\n  //     texttargetLocation = text(\"no target\")\n  //     inboundText = text(\"INBOUND\",\"arial\",\"white\", 20, -10)\n  //     outboundTExt = text(\"OUTBOUND\",\"arial\",\"white\", 20, -10)\n  //     textSpeed.x = 100\n  //     textTwisterY.x = 200\n  //     textCraneX.x =300\n  //     textTwisterSpeed.x =400 \n  //     texttargetLocation.x = 500\n  //     textBox.addChild(textSpeed)\n  //     textBox.addChild(textTwisterY)\n  //     textBox.addChild(textTwisterY)\n  //     textBox.addChild(textCraneX)\n  //     textBox.addChild(textTwisterSpeed)\n  //     textBox.addChild(texttargetLocation)\n  // inbound.addChild(inboundText)\n  // outbound.addChild(outboundTExt)\n  // red dot for searching the pivot\n\n  dot = Object(_library_display__WEBPACK_IMPORTED_MODULE_0__[\"circle\"])(6, \"red\");\n  dot.x = 50;\n  dot.y = 36;\n  twister.addChild(dot); //start the game loop\n\n  gameLoop();\n  console.log(rack);\n}\n\nfunction gameLoop() {\n  requestAnimationFrame(gameLoop);\n  play();\n} // The logis of the program\n\n\nfunction play() {\n  if (twister.children[1]) {\n    twister.busy = true;\n  } else {\n    twister.busy = false;\n  } //Checking every location on the rack for interaction, doing the main logic of the game\n\n\n  rack.children.forEach(function (location) {\n    /* when mouse is over one location, the location is red, When we click on the location it will be pick up location,\r\n     if we have pickpu location selected, it will be destination */\n    if (pointer.hitTestSprite(location)) {\n      location.fillStyle = 'red'; // If the pickuplocation is 0 than we know that this is position for pickup - add position as pickup\n\n      if (pointer.isDown && pickUpLocation.length == 0 && location.children.length != 0 && location.name == \"rack\") {\n        pickUpLocation.push(location.centerX, location.centerY, location.index);\n        console.log(pickUpLocation[2]); // THE INFOBOX   texttargetLocation.content = `X:${location.x},Y:${location.y}`\n\n        pointer.isDown = false; // If the pickuplocation is more than 0 we know that this is position for destination - add position as destination\n      } else if (pointer.isDown && pickUpLocation.length > 0 && location.children.length == 0 && location.name == \"rack\") {\n        destinationLocation.push(location.centerX, location.centerY, location.index);\n        order = Object(_order__WEBPACK_IMPORTED_MODULE_5__[\"newOrder\"])(pickUpLocation[0], pickUpLocation[1], location.message, destinationLocation[0], destinationLocation[1], location.name, pickUpLocation[2], destinationLocation[2]);\n        console.log(order);\n        orders.push(order);\n        pickUpLocation = [];\n        destinationLocation = [];\n        pointer.isDown = false;\n        location.selected = true; //If the location name is outbound than \n      } else if (pointer.isDown && pickUpLocation.length > 0 && location.name == \"outbound\") {\n        destinationLocation.push(location.centerX + location.width / 2 - 27, location.centerY, location.index);\n        order = Object(_order__WEBPACK_IMPORTED_MODULE_5__[\"newOrder\"])(pickUpLocation[0], pickUpLocation[1], location.message, destinationLocation[0], destinationLocation[1], location.name, pickUpLocation[2], destinationLocation[2]);\n        console.log(order);\n        orders.push(order);\n        pickUpLocation = [];\n        destinationLocation = [];\n        pointer.isDown = false;\n        location.selected = true;\n      }\n    } else {\n      if (location.selected) {\n        location.fillStyle = 'yellow';\n      } else {\n        location.fillStyle = 'black';\n      }\n    } // Logic and movement for in and outbound\n    // OUTBOUND - recieving the box and shift it out from the silo\n    // If there is a box on the outbound - move it out from the silo\n\n\n    if (location.name == \"outbound\" && location.children != 0) {\n      if (location.children[0].x > 0) {\n        location.children[0].x -= 1;\n      } else {\n        location.children.shift();\n        location.occupied = false;\n      }\n    } //INBOUND - creating a new box, making it ready for the crane  \n\n\n    if (location.name == \"inbound\" && location.children != 0) {\n      location.children.forEach(function (b) {\n        if (b.x + b.width < inbound.width) {\n          b.x++;\n        } else {\n          //check if the destination is valid and make sure order happens once\n          if (rack.children[b.destination] && inboundJob == false) {\n            var orx = rack.children[b.destination].centerX;\n            var ory = rack.children[b.destination].centerY;\n            var nm = \"inbound\";\n            destinationLocation.push(orx, ory, b.destination);\n            order = Object(_order__WEBPACK_IMPORTED_MODULE_5__[\"newOrder\"])(inbound.centerX + location.width / 2 - 27, inbound.centerY, b.message, destinationLocation[0], destinationLocation[1], nm, -1, destinationLocation[2]);\n            console.log(order);\n            orders.push(order);\n            destinationLocation = [];\n            inboundJob = true;\n          }\n        }\n      });\n    }\n  }); //Checking every box in boxes array, if there is a new box in array with location of -1 make it children of inbound\n\n  boxesArray.forEach(function (box) {\n    if (box.locationIndex == -1 && box.waiting == true) {\n      inbound.addChild(box);\n      box.waiting = false;\n    }\n  });\n\n  if (orders.length > 0) {\n    // PICKUP\n    if (!twister.busy) {\n      var dotGlobalX = dot.globalBounds.x + dot.radius;\n      var dotGlobalY = dot.globalBounds.y + dot.radius;\n      var posXGlobal = orders[0].positionX + rack.globalBounds.x;\n      var posYGlobal = orders[0].positionY + rack.globalBounds.y;\n      var dx = (posXGlobal - dotGlobalX) * 0.02;\n      var dy = (posYGlobal - dotGlobalY) * 0.05; //calculate the distance this would move ...\n\n      var dist = Math.sqrt(dx * dx + dy * dy); //... and cap it at 5px\n\n      if (dist > 5) {\n        dx *= 5 / dist;\n        dy *= 5 / dist;\n        console.log('...pickup...'); //If the twister arrived to the destination...\n      } else if (dist < 0.05) {\n        //get the location data from the order\n        var loc;\n\n        if (orders[0].locationName == \"rack\") {\n          loc = rack.children[orders[0].locationIndex];\n        } else if (orders[0].locationName == \"inbound\") {\n          loc = inbound;\n        }\n\n        var destLoc = rack.children[orders[0].destinationIndex]; //check if the dot is touching box - which is children of the location, if not Delete the order and deselect the destination\n\n        if (loc.children[0]) {\n          //check the touching with the box\n          if (Object(_library_collision__WEBPACK_IMPORTED_MODULE_3__[\"hitTestCircleRectangle\"])(dot, loc.children[0], true)) {\n            var b = loc.children[0];\n            console.log(loc.children[0]);\n            twister.addChild(b);\n            b.x = dot.x - b.width / 2 + 3;\n            b.y = dot.y - b.height / 2 + 3;\n            loc.occupied = false;\n          } //If there is no box \n\n        } else {\n          console.log('Error ! - Location is empty...\\n Deleting order...');\n          destLoc.selected = false;\n          orders.shift();\n        }\n      }\n    } // DELIVERY\n\n\n    if (twister.busy) {\n      var _dotGlobalX = dot.globalBounds.x + dot.radius;\n\n      var _dotGlobalY = dot.globalBounds.y + dot.radius;\n\n      var _posXGlobal = orders[0].destinationX + rack.globalBounds.x;\n\n      var _posYGlobal = orders[0].destinationY + rack.globalBounds.y;\n\n      var dx = (_posXGlobal - _dotGlobalX) * 0.02;\n      var dy = (_posYGlobal - _dotGlobalY) * 0.05; //calculate the distance this would move ...\n\n      var dist = Math.sqrt(dx * dx + dy * dy); //... and cap it at 5px\n\n      if (dist > 5) {\n        dx *= 3 / dist;\n        dy *= 5 / dist;\n        console.log('...start delivery...');\n      } else if (dist < 0.05) {\n        var arrivedToDest = Object(_library_collision__WEBPACK_IMPORTED_MODULE_3__[\"hit\"])(dot, rack.children, false, false, true, function (collision, location) {\n          console.log(\"check if location is used: \" + location.occupied);\n\n          if (!location.occupied) {\n            var _b = twister.children[1];\n            location.addChild(_b);\n            location.occupied = true;\n\n            if (location.name == \"outbound\") {\n              _b.x = location.width - _b.width;\n              _b.y = location.height - _b.height;\n            } else {\n              _b.x = 0;\n              _b.y = 0;\n            }\n\n            orders.shift();\n            location.selected = false;\n            console.log(\"box delivered\");\n            inboundJob = false;\n          } else {\n            //Reject the box if the position is ocupied\n            console.log(\"placement fail! - location is occupied! \\n \");\n            orders.shift();\n            order = Object(_order__WEBPACK_IMPORTED_MODULE_5__[\"newOrder\"])(0, 0, \"Failed to deliver\", -27, 315, \"outbound\", 0, -2);\n            orders = [order].concat(_toConsumableArray(orders));\n            inboundJob = false;\n          }\n        });\n      }\n    }\n\n    craneAll.x += dx;\n    twister.y += dy;\n  } // Movement dinamics\n\n\n  if (crane.moveRight) {\n    crane.speed += 0.03;\n  } else if (crane.moveLeft) {\n    crane.speed -= 0.03;\n  } else {\n    crane.speed *= crane.frictionX;\n  }\n\n  crane.accelerationX = crane.speed;\n  crane.vx = crane.accelerationX;\n  craneAll.x += crane.vx;\n\n  if (twister.moveUp) {\n    twister.speed -= 0.03;\n  } else if (twister.moveDown) {\n    twister.speed += 0.03;\n  } else {\n    twister.speed *= twister.frictionY;\n  }\n\n  twister.accelerationY = twister.speed;\n  twister.vy = twister.accelerationY;\n  twister.y += twister.vy; //Text and info dynamics\n  // textSpeed.content = `Speed: ${crane.accelerationX.toFixed(4)}`\n  // textTwisterY.content = `Height: ${(crane.height -120 - twister.y).toFixed(4)}`\n  // textCraneX.content = `Position X: ${craneAll.x.toFixed(4)}`\n  // textTwisterSpeed.content = `Y Speed: ${twister.speed.toFixed(4)}`\n  // Making and Adding new box\n\n  if (pointer.hitTestSprite(addBoxButton)) {\n    addBoxButton.fillStyle = \"darkgrey\";\n\n    if (pointer.isDown) {\n      console.log(overlay.style.visibility);\n      overlay.style.visibility = \"visible\";\n      pointer.isDown = false;\n    }\n  } else {\n    addBoxButton.fillStyle = \"grey\";\n  } //render on the canvas\n\n\n  Object(_library_display__WEBPACK_IMPORTED_MODULE_0__[\"render\"])(canvas);\n}\n\n//# sourceURL=webpack:///./src/js/main.js?");

/***/ }),

/***/ "./src/js/order.js":
/*!*************************!*\
  !*** ./src/js/order.js ***!
  \*************************/
/*! exports provided: newOrder */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"newOrder\", function() { return newOrder; });\nfunction newOrder(x, y, message, desX, desY) {\n  var locName = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : \"rack\";\n  var locIndex = arguments.length > 6 ? arguments[6] : undefined;\n  var destInd = arguments.length > 7 ? arguments[7] : undefined;\n  var order = {\n    positionX: x,\n    positionY: y,\n    message: message,\n    destinationX: desX,\n    destinationY: desY,\n    locationName: locName,\n    locationIndex: locIndex,\n    destinationIndex: destInd\n  };\n  return order;\n}\n\n//# sourceURL=webpack:///./src/js/order.js?");

/***/ })

/******/ });